{WinHelper V1.05 by FNX A1 2022}
{TITTLE}
{WIN_W}00551
{JPG_SIZE}00141
{IMG_AUTO}10156
{WIN_DESC_H}00516
{WIN_DESC_PIC_H}00190
{WIN_EDT_GRP_H}00265
{WIN_ALING_LEFT}00000
{WIN_IMG_CFG}.0010.0010.0640.0480.0100
{PANLAT_CLR}000,255,000

*MODELOS
	·20230728141152
	:https://www.cgtrader.com/es/3d-modelos?file_types[]=104&free=1
	:
	*Estructura de datos
		·20230725182114
		:esquema básico de la estructura de datos en Blender. Ten en cuenta que Blender tiene una estructura de datos compleja debido a su naturaleza 3D y su enfoque en la creación de escenas y animaciones. A continuación, se presenta un resumen simplificado de los principales componentes de la estructura de datos en Blender:
		:Blend File (Archivo de Blender):
		:Contiene todos los datos de la escena, incluyendo objetos, materiales, texturas, animaciones, etc.
		:Puede tener múltiples escenas, cada una con su propio conjunto de datos.
		:Escena (Scene):
		:Contiene objetos y otros elementos que conforman una escena 3D completa.
		:Cada archivo de Blender puede tener múltiples escenas.
		:Objetos (Objects):
		:Representan los elementos visibles en la escena, como mallas, cámaras, luces, etc.
		:Los objetos pueden estar organizados en diferentes capas de la escena.
		:Mallas (Meshes):
		:Representan objetos 3D compuestos por vértices, aristas y caras.
		:Contienen la información de la geometría del objeto.
		:Materiales (Materials):
		:Definen cómo se muestra el objeto, incluyendo color, texturas, brillo, etc.
		:Texturas (Textures):
		:Son imágenes o patrones que se aplican a los materiales para agregar detalles visuales.
		:Armaturas (Armatures):
		:Representan esqueletos que se utilizan para animar objetos mediante deformaciones (skinning).
		:Las armaduras se componen de huesos que tienen relaciones jerárquicas entre sí.
		:Fotogramas clave (Keyframes):
		:Se utilizan para definir los valores de las propiedades en momentos específicos del tiempo para crear animaciones.
		:Se pueden agregar a diferentes propiedades de objetos, como posición, rotación, escala, etc.
		:Acciones (Actions):
		:Contienen fotogramas clave y definen animaciones que se pueden aplicar a objetos o huesos.
		:Fcurves (Curvas de animación):
		:Representan las trayectorias de las animaciones en función del tiempo.
		:Se componen de fotogramas clave y se utilizan para animar propiedades específicas de objetos.
		:Es importante tener en cuenta que esta es solo una visión general simplificada de la estructura de datos en Blender. La aplicación en sí misma es mucho más compleja y ofrece una amplia gama de herramientas y funcionalidades para la creación de contenido 3D y animaciones. Sin embargo, espero que esta descripción te dé una idea general de cómo están organizados los datos en Blender.
		:Claro, puedo proporcionarte un ejemplo en C# para crear una estructura similar a la de Blender para armaduras (esqueletos) y mallas. Ten en cuenta que esta estructura simplificada en C# no incluirá todas las características y funcionalidades avanzadas de Blender, pero te ayudará a comprender cómo se pueden representar los datos básicos en C#.
		:Primero, definiremos las clases para la Armadura y los Huesos:
		:csharp
		:Copy code
		:using System;
		:using System.Collections.Generic;
		:public class Bone
		:{
		:public string Name { get; set; }
		:public Vector3 Head { get; set; }
		:public Vector3 Tail { get; set; }
		:public Matrix4x4 Matrix { get; set; }
		:public List<Bone> Children { get; set; }
		:public Bone(string name, Vector3 head, Vector3 tail, Matrix4x4 matrix)
		:{
		:Name = name;
		:Head = head;
		:Tail = tail;
		:Matrix = matrix;
		:Children = new List<Bone>();
		:}
		:}
		:public class Armature
		:{
		:public List<Bone> Bones { get; set; }
		:public Armature()
		:{
		:Bones = new List<Bone>();
		:}
		:}
		:A continuación, definimos las clases para la Malla, Vértices, Aristas y Caras:
		:csharp
		:Copy code
		:public class Vertex
		:{
		:public Vector3 Position { get; set; }
		:public List<int> VertexGroupIndices { get; set; }
		:public List<float> VertexGroupWeights { get; set; }
		:public Vertex(Vector3 position)
		:{
		:Position = position;
		:VertexGroupIndices = new List<int>();
		:VertexGroupWeights = new List<float>();
		:}
		:}
		:public class Edge
		:{
		:public int VertexIndex1 { get; set; }
		:public int VertexIndex2 { get; set; }
		:public Edge(int v1, int v2)
		:{
		:VertexIndex1 = v1;
		:VertexIndex2 = v2;
		:}
		:}
		:public class Face
		:{
		:public List<int> VertexIndices { get; set; }
		:public List<int> EdgeIndices { get; set; }
		:public Face(List<int> vertexIndices)
		:{
		:VertexIndices = vertexIndices;
		:EdgeIndices = new List<int>();
		:}
		:}
		:public class Mesh
		:{
		:public List<Vertex> Vertices { get; set; }
		:public List<Edge> Edges { get; set; }
		:public List<Face> Faces { get; set; }
		:public Mesh()
		:{
		:Vertices = new List<Vertex>();
		:Edges = new List<Edge>();
		:Faces = new List<Face>();
		:}
		:}
		:Recuerda que esta es una estructura simplificada y que en una implementación real, podrías agregar más propiedades y métodos para manipular y gestionar los datos según tus necesidades.
		:Espero que este ejemplo te sea útil para comprender cómo podrías representar la estructura de datos de armaduras y mallas en C#. Si tienes más preguntas o necesitas más ayuda, no dudes en preguntar. ¡Estoy aquí para ayudarte!
		:
	*NEW
		·20230725174350
	*NEW
		·20230725174350
*Ventana Compositor
	·20230728141152
	:https://www.youtube.com/watch?v=M2l-NH-lkQE
	:
*Ventana ViewPort3D
	·20230728141152
	:Es la pantalla principal de diseño 3D
	:
	*Herramientas
		·20230725170039
		*Snap (Ajuste Himan)
			·20230725182114
			ª10033ª10034
			:Permite igualar la posicon de lo que creemos o desplacemos a la
			:cara, arista, vertice u objeto sobre el que estemos.
			:Tenemos distintas opciones
			:-Increment (Ajusta al grill)
			:-Vertex (Ajusta con el vertice enfocado)
			:-Edge (Ajusta con la arista enfocado)
			:-Face (Ajusta con la Cara enfocado)
			:-Volume (Ajusta con el Objeto enfocado)
			:-Edge Center (Ajusta con el centro de la arista enfocada)
			:-Edge Perpendicular (Ajusta con el centro de la arista enfocada perpendicularmente.)
			:Dentro de cada modo podemos indicarle otras opciones
			:-Como que tambien copie la rotacion o que se aline con la normal.
			:-Que se alinne con el centro , la media
			:-Tambien que que se mueva, rote o escale segun el objeto enfocado.
			:
*Ventana Properties
	·20230725170039
	*Object Properties (Propiedades del objeto)
		·20230725170039
		*Transform
			·20230725170039
		*Relations
			·20230725170039
		*Collections
			·20230725170039
		*Instancing
			·20230725170039
		*Motion Paths
			·20230725182114
			ª10067
			:Activa el trazado del objeto animado pudiendo configurar distintos modos
			:como el rango, si muestra key frames, Color, lineas, Numero de Fotogramas
			:Es necesario actualizarlo con cada modificacion de la animacion con "Update Paths"
			:
		*Visibility
			·20230725170039
		*ViewPort Display
			·20230725170039
		*Custom Properites
			·20230725170039
*Modificadores
	·20230728141152
	ª10022ª10023ª10028
	:https://www.youtube.com/watch?v=s7-l1GB-mnA&list=PLfU-cGMkAuc4b7p43N5wveJ3NvKzj6Ael
	:Son operaciones que se realizan sobre un bojeto para deformarlo o
	:modificarlo.
	:Segun el tipo de objeto que tengamos selecionado nos mostrara
	:los que podemos aplicar.
	:Tenemos de 4 tipos: MODIFICADORES, GENERADORES, DEFORMADORES y FISICAS
	:Podemos aplicar distintos modificadores a los objetos, rectificando
	:unos efectos sobre otros hasta conseguir lo que necesitemos..
	:Podemos tambien ordenar los modificadores de modo que
	:sobre el resultado de un modificador realize otro y sobre este resultado
	:otro mas.
	:Tambien podemos indicar si queremos que se renderize, se muestre,
	:se aplique o incluso modificar los resultados con los botones superiores.
	:Tambien podemos modificar el nombre del modificador.
	:Y cuando estemos contentos podemos aplicar los cambios.
	:Si no se apican se calcularan a tiempo real siempre, que tambien es
	:una opcion pero consume recursos, usar a discreccion.
	:
	*MODIFICADORES (Modify)
		·20230725182114
		:Lo que hacen realmente es recopilar datos de un objeto, tratarlos y
		:pasarselos a otro objeto.
		:
		*Data Transfer
			·20230725170039
		*MESH CACHE (En DesUso)
			·20230725182114
			ª10021ª10032ª10035
			:Permite exportar e importar una animacion de un objeto dado.
			:En propiedades tenemos que permitir exportar en formato MDD.
			:Es necesario que los objetos sean identicos.
			:Nos permitiria mezclar,encadenar o guardar distintas animaciones.
			:Tambien nos permite modificar el tiempo total de la animacion.
			:Actualmente ya no se usa, remplazado por el ACTION EDITOR
			:https://www.youtube.com/watch?v=pzhr_JUcT_4&list=PLfU-cGMkAuc4b7p43N5wveJ3NvKzj6Ael&index=3
			:
		*Mesh Sequece Cache (Alembic ABC)
			·20230725182114
			ª10038ª10039
			:Nos permite importar objetos y animaciones de formato ALEMBIC .ABC
			:Si modificamos la maya de los objetos dejara de funcionar pero
			:si podemos indicar que nos muestre Vertices,Caras,UVs o Colores
			:la velocidad y otros parametros.
			:
		*Normal Edit (En DesUso)
			·20230725182114
			ª10040ª10041ª10042ª10043
			:Este modificador se aplica sobre un objeto y permite
			:configurar las normales que se muestran segun la posicion de otro objeto
			:Se usa para que en objeos planos sus normales se ajusten de forma automatica
			:y sean visibles segun la posicon del objeto B (la camara por ejemplo)
			:Es necestario tener activo el AUTO SMOOTH en OBJECT DATA PROPERTIES
			:Nos auto orienta las normales de un objeto segun otro de referencia para que solo
			:sean visibles las caras que apuntan a ese objeto.
			:https://www.youtube.com/watch?v=QZgmJ39cZCs&list=PLfU-cGMkAuc4b7p43N5wveJ3NvKzj6Ael&index=6
			:
		*Weighted Normal
			·20230725182114
			ª10044ª10045ª10046
			:Este modificador se aplica sobre un objeto y nos aplica con poca geometria una curba
			:Podemos aplicarselo solo aun grupo de vertices de un objeto y podemos
			:marcar costuras para indicarle que zonans no queremos que aplique el suabizado.
			:Es necestario tener activo el AUTO SMOOTH en OBJECT DATA PROPERTIES
			:
		*UV Project
			·20230725182114
			ª10047ª-1ª10051ª10052
			:Este modificador nos permite modificar la posicion, Rotacion y escala de las UVs
			:de un objeto segun otro objeto, sin tener que modificar las UVs o el material.
			:Creamos el objeto, sus UVs y el material.
			:Le aplicamos el modificador.
			:Le asignamos otro objeto para que calcule el desplazamiento de las UVs
			:Usara la diferencia entre las Transformaciones del objeto base y el objeto ayudante.
			:
		*UV Warp
			·20230725182114
			ª10048ª10049
			:Este modificador nos permite modificar la posicion, Rotacion y escala de las UVs
			:de un objeto usando la diferencia entre las transformaciones de dos objetos.
			:Ejemplo: Objeto1.X - Objeto2.X = Desplazamiento X de la normal.
			:Podemos definir el centro de la UV
			:siendo 0,0 La Esquina Inf-Izq 0.5,0.5 El Centro y 1,1 la esquina Sup-Der
			:Tambien podemos aplicar el desplazamiento solo a un Vertex Group
			:Modificar los Ejes o los desplazamientos bases, Rotacion y escala.
			:
		*Vertex Weight Edit
			·20230725182114
			ª10053ª10054ª10055ª10056
			:Este modificador nos permite ajustar distintos parametros de un grupo de vertices
			:y sus pesos.
			:Podremos tener tantos modificadores como grupos de vertices necesitemos.
			:Nos permite ajustar
			:Desde que valor se considera 1 (el tope) o Normalizar los pesos, definir el modo de
			:extenderse o invertir el grupo etc.
			:
		*Vertex Weight Mix
			·20230725182114
			ª10057ª10058ª10059ª10060ª10061
			:Nos permite mezclar distintos grupos de vertices con sus pesos.
			:Teniendo dos grupos de vertices y sus pesos en el mismo objeto
			:podemos aplicar distintas operaciones para mezclarlos, fundirlos
			:restarlos o ajustarlos
			:
		*Vertex Weight Proximity
			·20230725182114
			ª10062ª10063ª10064ª10065ª10066
			:Nos permite modificar la intensidad de los pesos de un grupo
			:de vertices segun la proximidad de otro objeto.
			:Tenemos un objeto con un grupo de vertices con pesos.
			:Tenemos otro objeto animado que se aproxima a este objeto.
			:Al aproximarse los pesos de los vertices del Vertex Group tambien
			:se modifican.
			:Podemos indicarle distancia minima y maxima, tipo de afectacion
			:si vertices , aristas o caras, etc.
			:
	*GENERADORES (Generate)
		·20230725182114
		:Modifica o deforma la geometria de un objeto.
		:
		*ARRAY
			·20230725182114
			ª10029ª10068ª10070ª10069ª10071ª10072ª10073
			:Nos crea una o mas copias de un objeto.
			:Podemos definir:
			:-Count. El numero de copias .
			:-Relative OffSet. El factor de desplazamiento por objetos,
			:-Constant OffSet. El desplazamiento por distancia
			:-Object OffSet. El desplazamiento por posicion de objeto
			:este modo tambien permite no solo un desplazamiento
			:tambien nos permitiria rotar rotacion las copias.
			:tenemos que tener en cuenta que la rotacion y desplazamiento
			:las tomara desde el objeto guia hasta su origen y la rotacion
			:del origen.
			:-Merge. Permite deformar la maya de las copias para que se
			:unan a la anterior pudiendo respetar la primera y la ulitma copia.
			:-UVs. Realiza un desplazamiento en el UV para que las texturas
			:no sean iguales (NT:1=100% 0=0% del tamaño de la UV)
			:-Caps. Permite definir los objetos de inicio y final del Array.
			:
		*BEVEL
			·20230725182114
			ª10074ª10075ª10109ª10076ª10077ª10078ª10079
			:Nos permite suabizar los bordes de un objeto añadiendo
			:geometria usando bien las aristas o los vertices.
			:Redondeando lados o esquinas.
			:-Podemos calcular el incremento segun algunos factores.
			:Offset. segun el tamaño de la X
			:Width. Segun el tamaño de la diagonal.
			:Depth. Segun el tamaño de la bisectric.
			:Percent. aplicamos segun el % del tamaño de la cara adjunta
			:Absolute. Segun el tamaño de la cara adjunta.
			:-Podemos aplicar un limitador para que solo afecte a:
			:Nada. pues eso .. sin limite
			:Angle. Solo afectara a lo que este por encima del angulo dado.
			:Weight. Segun el peso de la arista o vertice.
			:NT:Podemos configurar los pesos de las aristas, selecionandolas
			:y en la pestaña ITEM del 3DVIEW definir el Bevel Weight.
			:-En Profile podemos definir el tipo de curva.
			:Superellipse. Indica la dureza de la curva 0.0=Interior ... 1.0=Exterior
			:Custom. Este modo nos permite definir la forma de la curva.
			:Nos mostrara el numero de divisiones con puntos oscuros en la curva.
			:-En Geometry . Definimos si queremos corte. (solo funciona en aristas)
			:Miter=Inglete (Util diseñado para cortar maderas en distintos grados)
			:Podemos definir el tipo de interseciones, el tipo de corte interior y exterior
			:Si queremos que sea por angulo, por arco, etc.
			:Intersetion. Nos permitira rellenar lo cortado o dejarlo liso.
			:-Shading
			:indicaremos si queremos que marque mas las Normales.
			:Si queremos que considere las SEAM las Costuras.
			:O el numero de material a aplicar en el Bevel.
			:
		*BOOLEAN
			·20230725182114
			ª10080ª10081ª10082
			:-Este modificador nos permite realizar operaciones de
			:union, insercion y resta entre distintos objetos.
			:Union. Genera un objeto con dos objetos unidos.
			:Insercion. Genera un objeto con los cruzes de dos objetos.
			:Substracion. Genera un objeto con el Objeto A menos el Objeto B.
			:-Este modificador genera una geometria sucia que luego
			:tendremos que limpiar.
			:-Los objetos tienen que estar cerrados ya que se rompe
			:muy Facil mente.
			:Podemos usar el metodo antiguo FAST (Por proximidad) o el
			:metodo nuevo EXACT (consume mas recursos)
			:Tambien podmos decirle que use metodo OBJETO o una colecion
			:solo de Vertices, Aristas, pesos etc.
			:
		*BUILD
			·20230725182114
			ª10083ª10084
			:Este modificador nos genera una animacion donde un objeto
			:se crea o elimina cara a cara en un numero de fotogramas.
			:Podemos indicarle.
			:- Fotograma de inicio y final
			:- Si queremos que lo Genere o lo Elimine (Reverse)
			:- Si queremos que lo realize de forma Aleatoria.
			:Por defecto el lo Crea/Elimina por orden de loops y de
			:menor a mayor.
			:
		*DECIMATE
			·20230725182114
			ª10085ª10086
			:Este modificador nos limpia geometria quitando el detalle
			:en exceso.
			:Tenemos tres modos.
			:- Collapse. Elimina caras en un % de 0.0-1 Triangulando la geometria.
			:Symetry. nos pemite priorizar un eje para que no lo deforme.
			:Vertex Group. Permite definir que grupo de vertices sera afectado.
			:- UnSubdivision. Intenta mantener la geometria buscando iteraciones
			:entre aristas elimiandolas y procurando mantener la base (Elimina
			:iteraciones repetidas) Guarda muy bien la geometria.
			:- Planar. Elimina geometria con un grado minimo pudiendo decirle
			:que quiere mantener si por Normale, Material, costuras.
			:Es muy destructivo.
			:
		*EDGE SPLIT
			·20230725182114
			ª10087ª10088
			:Este modificador nos permite separar las caras del objeto.
			:Manteniendo el objeto permite des-atar sus caras de las caras
			:contiguas segun un angulo.
			:
		*GEOMETRY NODES
			·20230725182114
			:Explicado en un apartado propio de lo estenso que es.
			:Se trata de un sistema de generacion de objetos damico donde
			:podemos programar algunas cosas.
			:En la actualidad lo han reconstruido y es completamente distnto
			:siendo mucho mas potente que este.
			:Es tan potente que tiene su propia plantilla de trabajo
			:De momento lo veremos por encima.
			:
		*MASK
			·20230725182114
			ª10089ª10090ª10091
			:Permite crear grupos de geometria de un objeto para ocultarla.
			:Trabaja sobre:
			:-Grupos de vertices.
			:Creamos grupos de vertices y le asignamos el grupo a la mascara.
			:Podemos indicar que nos muestre u oculte segun el peso asignado.
			:O que nos muestre el resto menos el grupo.
			:-Huesos.
			:Al igual que por grupos en este caso nos mostraria solo el grupo
			:de vertices asociado a un hueso (en Pose Mode) o la inversa.
			:
		*MIRROR
			·20230725182114
			ª10026ª10027ª10092
			:Cea una compia espejo de un modelo en uno o mas ejes.
			:AXIS - Podemos definir sobre cual eje realizara el espejo
			:FLIP - Podemos voltear las copias. (no logro que funcione)
			:BISECT - Obtenemos la Bisectriz (la zona interna que colisiona.)
			:CLIPPING - le indica que elimine los vertices que colisionen.
			:MERGE - le india la distancia minima para que fusiones vertices proximos.
			:en DATA podemos definir:
			:un desplazamiento a las texturas.
			:Un inicio desplazado a las texturas.
			:Si queremos que use UDIM (Texturas multi imagen)
			:Si usa Vertex Groups para las texturas.
			:MIRROR OBJECT - Para saber desde donde trazar el espejo usa el centro
			:del objeto pero tambien podemos indicar que use el centro
			:de otro objeto, en este caso tomara desplazamiento y rotacion tambien.
			:
		*MULTIRESOLUTION
			·20230725182114
			ª10094ª10093ª10095
			:Añade subdivisiones a una geometria para darle detalle.
			:Trabaja DIRECTAMENTE sobre la geometria origina, no
			:puede usar objetos con geometria modificada por otro
			:modificador.
			:-Tenemos tres modos de subdivision:
			:Normal - Ajusta entre extremos del objeto, suabiza el objeto
			:Simple - Ajusta entre las caras del objeto, suabiza las caras
			:Lineal - Solo divide , no suabiza nada.
			:-Podemos indicar el nivel de detalle en el ViewPort, Sculp o Render.
			:-Optimal Display - Nos muestra el contorno del objeto (el cuadro)
			:- UnSubDivide - Des hace una o mas subdivisiones si no se han editados.
			:- Delete Higher- Elimina subdibisiones superiores.
			:Al igual que en UnSudivision si tenemos 6 pasos y mostramos solo hasta el 4
			:con estas opciones nos permite bajar la geometria hasta el paso 4.
			:-SHAPE - Resape - Nos permite copiar desde otro objeto con la misma geometria.
			:-SHAPE - Apply Base - Nos dejaria el objeto inicial lo mas parecido al actual.
			:- GENERATE - nos permite guardar toda la maya, pasos y ajustes en un fichero
			:para cargarlos en otras aplicaciones (es como el LOD en videojuegos donde
			:tenemos un objeto con muchos poligonos, el mismo con menos..menos..menos..etc.
			:-Advanced - Nos permite configurar el modo en que esta trabajando, si queremos
			:que tenga en cuenta los pesos de aristas (CRASES) o si tiene que usar normales
			:de otro modificador etc.
			:
		*REMESH
			·20230725182114
			ª10096ª10097
			:Genera una geometria basandose en la del objeto actual.
			:NT: por la cantidad de geometria que genera es muy facil que se rompa el blender.
			:Genera la geometria como por capas de delanta hacia atras del objeto.
			:Tenemos distintos modos de generar la nueva geometra.
			:Voxel - intenta crear siempre Quads (Voxels)
			:-Voxel Size - Tamaño de los cuadros.
			:-Adaptivity - Tamaño para ajustar mas los cuadros (permitiendo Triangulos)
			:Smooth - Modo fino, Permite ajustar Profundidad y escala de los cuadros.
			:Sharp- gual que Smooth pero tambien permte definir el Sharpness o el tope fino.
			:Blocks (Bloques) - Podemos ajustar la profundidad DEPTH y la escala de los
			:bloques.
			:Con Remove Disconnected podemos decirle que elimine geometria en caso
			:de que quede algun trozo sin conectar.
			:Con Threshold le indicamos la distancia para eliminar lo no conectado.
			:Smooth Shading nos permite suabizar el resultado sin añadir geometria.
			:
		*SCREW
			·20230725182114
			ª10101ª10100ª10099ª10098
			:Este modificador crea desde una geometria basica un TORNILLO o Tornado.
			:Es una evolucion del Edge.Screw donde podiamos desde una geometria
			:basica generar torsiones, caracoles, etc.
			:Con el Modificador SCREW tenemos mas control y permite mas opbiones.
			:En los dos caso se basa en un poligono o geometria plana.
			:Podremos definir :
			:El Angulo - El tamaño del arco que trazara.
			:El Screw - Tamaño de desplazamiento de la espiral.
			:Iterations - Numero de repeticiones para el loop.
			:Axis - El eje sobre el que queremos que las realize
			:Axis Object - Le podemos indicar que en lugar de basarse en la
			:diferencia entre la distancia entre el eje del objeto y cada vertice,
			:se calcule con respecto al eje de otro objeto.
			:Object Screw - Le indicamos que el tamaño del tornillo lo calcule
			:con respecto al eje del objeto ayudante.
			:Steps Vieport / Render - El nivel de detalle para la vista y el render.
			:Merge - Permite fundir vertices en caso de los Screw esten muy proximos.
			:Stretch UVs - Ajusta las uvs para que coincidan mejor entre las texturas
			:de las distintas Iteraciones.
			:Smooth Shadin - Suabiza los bordes.
			:Calculate Order - Recalcula el orden de dibujo de las caras.
			:Flip - Voltea las normales (Dentro/Fuera)
			:
		*SKIN
			·20230725182114
			ª10107ª10106ª10104ª10103ª10102
			:Este modificador crea sobre las aristas de un objeto una piel o envolvente.
			:Podemos crear un muñeco de palo y con este modificador creariamos
			:una piel para despues darle mas detalle.
			:Tambien podemos crear otros bojetos, cadenas , paredes, etc. de forma
			:muy rapida.
			:Este Mod se trabaja en "EDIT MODE"
			:Podemos indicarel:
			:-Branch Smoothing - (Suavizadp de las ramas) Indica el tamaño de cada punto con respecto
			:a los que le rodean para plicar reducion de caras.
			:-Symmetry - Indica para cada punto si aplica simetria de caras añadidas.
			:-Smooth Shading - (Suavizar Sombreado)
			:-Clear Loose - Re Calcula los vertices sueltos que ya no son utiles y recalcula caras.
			:-Mark Loose - Marca un vertice colo suelto o perdido.
			:-Mark Root - Marca un vertice como centro de la geometria (hueso Root).
			:-Equalize Radii - (Igualar Radios) de los vertices selecionados.
			:-Create Armature - Permite crear con un click la armature segun la estructura creada.
			:Luego tendremos que emparentar con pesos automaticos.
			:Cada vertice tiene un radio de alcance con X e Y que podemos ajustar con el panel
			:ITEMS.Mean Radius X/Y Tambien puese modificar las dos al tiempo con CTRL+A.
			:
		*SOLIDIFY
			·20230725182114
			ª10111ª10110ª10108
			:Este modificador Solidifica un objeto,
			:Tenemos dos Modos
			:- Complejo - Nos presenta algunas opciones mas de como generara las caras extra.
			:-Thickness Mode - (Modo De Expesor)
			:-Fixed / Even / Constrains -( Fijo / Angular / Restringido)
			:- Boundary - (Perimetro)
			:- None / Round / Flat (Ninguno / Redondeado / Plano)
			:- Merge Threshold - (Umbral de Fusion)
			:-Thickness -(Espesor) Indicamos el grosor de la capa siendo 0 el original, menos de 0
			:Interior y mas de 0 Exterior.
			:- OffSet -(Desplazamiento) Indicamos si es interior o exterior.
			:-Even Thickness - Espesor Uniforme. Ajusta el calculo para que las caras generadas sean
			:simetricas a las originales. (Por defecto son escaladas)
			:-Fill- (Relleno) Tapa todos las las caras.
			:-Only Rim - Solo el Anillo, Deja sin poner las caras superior e inferiro.
			:Tambien podemos Asignar un Grupo de Vertices para solo nos lo aplique a esos vertices.
			:Podemos indicarle el Factor o dureza que aplica a los vertices selecionado. 1=100%
			:O invertir la selecion con el boton lateral del Vertex Group.
			:Luego tenemos el tratamiento de las normales y del Material.
			:Edge Data - (Datos de borde) Como Generara las capas añadidas.
			:Thickness Clamp - Configuramos el tratamiento de los bordes.
			:Output Vertex Group- Nos permite exportar como grupo de vertices las capas
			:generadas para tratarlas con otros modificadores.
			:
		*SUBDIVISION SURFACE
			·20230725182114
			ª10024ª10025ª10112ª10105
			:Este modificador es tan usadoque tiene atajo de teclado CTRL + 1/2/3/4/5 segun detalle.
			:Tenemos dos modos:
			:- Catmul-Clark -sub divide considerando medias de caras y suabizando
			:- Simple - Sub divide partiendo caras simplemente (Es necesario aplicarlo, no se muestra directamente)
			:Despues tenemos el nivel en view port y el nivel en Render.
			:Optimal Display - En Wiere Frame muestra menos subdivisiones para que no sobrecargue la escena.
			:Use Limit Surface - Aplica la geometria generada lo mas posibel al poligono original (menos suabizado)
			:Quality - Configura el nivel de suabizado de la geometria.
			:UV Smooth - Configura las UVs para intentar ajustar las texturas con distintos modos.
			:Boundary Smooth- Si queremos que el intento de correcion de las texturas se aplique a todo o solo a esquinas.
			:Use Creases - Nos ayuda a no tener que hacer Loops de soporte (Partir la geometria).
			:Podemos en modo edicion definir la tension de cada cara selecionandola y con Sift+A la ajustamos.
			:o por el menu ITEM del ViewPort. Edges Data, Mean Crease. 0 = normal 1 = maxima tension.
			:Use Custon Normals - Se usa para ajustar mas aun los suabizados.
			:Se usa en EDIT MODE , nos crea un objeto simple como ayudante
			:para deformar la geometria de otro objeto.
			:En modo edicion podemos ver a tiempo real como queda el objeto Extruyendo , Dividiendo, etc.
			:
		*TRIANGULATE
			·20230725182114
			ª10113ª10114
			:Por defecto se trabaja con caras de 4 vertices (Quads) pero podemos usar caras de todos los
			:vertices que queramos (mas de 2 claro).
			:Este Mod nos parte la geometria para que todas las caras tengan 3 vertices.
			:En videojuegos siempre se trabaja en caras de 3 vertices pero para editar es mas comodo de 4.
			:Quad Method - Indica el metodo con el que parte las caras de 4 vertices (Quads)
			:N-gon Methos- Indica el metodo por el que parte las caras con mas de 4 Vertices (NGones)
			:Minimun Vertices - Indica el minimo numero de vertices de las caras a tratar (Caras con mas de X Vertices)
			:Keep Normals - Hace que el Triangulate no toque las normales, sobre todo si son tratadas
			:en otro modificador.
			:
		*VOLUME TO MESH
			·20230725182114
			ª10117ª10118ª10115ª10116ª10121
			:Este modificador fue añadido en la version 2.9 y ha fue añadido para poder crear fisicas de nubes.
			:No se aplica directamente sobre objetos, Necesita de un objeto alludante y para lo cual se
			:han añadido un objeto Volume / Empty.
			:Si a este objeto "Especial" le añadimos un modificador solo nos permitira dos.
			:Mesh to Volum y Volume Displace
			:Mesh to Volum - Nos permite configurar que objeto contendra el efecto y demas parametros.
			:-Object - Le indicamos el objeto que contendra el efecto y le dara forma.
			:- Density - La intensidad del efecto.
			:- Fill Volume - Si el efecto se aplica solo a la piel o a todo el objeto. objeto lleno.
			:- Exterior Band Widht - Cuanto sale del exterior de la piel del objeto.
			:Interiro nBand Widht - Cuanto se rellena del interior (Solo sin Fill)
			:Resolution Mode - Le indicamos si queremos que la calidad / Definicion se defina
			:en Numero de Voxels o en Tamaño de Voxels.
			:Tiene otro MOD que tambien se añade al VOLUME
			:Volume Displace - Este solo se encarga de dar una textura a las particulas de humo.
			:
		*WELD
			·20230725182114
			:Este modificador se usa tanto que lo han añadido como funcionalidad basica como
			:Mesh/ Clean Up/ Merge by distance.
			:Lo que hace basicamente es eso, coje un objeto y junta los vertices segun la distancia
			:que los separa.
			:En el modificador le podemos indicar:
			:Un grupo de vertices para que solo afecte ese grupo.
			:y que afecte a todos los vertices o solo a los grupos conectados.
			:
		*WIREFRAME
			·20230725182114
			ª10123ª10123ª10123ª10123ª10123
			:Este modificador hace solidas las aristas de nuestro objeto.
			:Podemos configurar:
			:- Thickness - Grosor de las aristas.
			:- Offset - Desplazamiento de las caras creadas hacia dentro o hacia fuera del objeto.
			:- Boundary - Si queremos que normalize las normales.
			:- Replace Original - Si queremos que mantenga la geometria original o no.
			:- Thickness.Even- Grosor igual para todas.
			:- Thickness.Relative- Grosor relativo
			:- Crease Edges -
			:- Material Offset - Nos permite dedicir cual de los materiales del objeto se aplicara.
			:- Vertex Group - Nos permite decidir en que vertices se aplicara el mayado.
			:- Factor - Indicamos el % de afection de los vertices selecionados.
			:
	*DEFORMADORES
		·20230725182114
		:Solo modifican geometria pero ni la crean ni la destruyen.
		:
		*ARMATURE
			·20230725182114
			ª10125ª10126ª10127ª10128
			:Este es el modificador encargado de modificar los grupos de vertices asociandolos a los huesos.
			:Lo podemos crear de forma manual o de forma automatica.
			:-MANUAL
			:1º Creamos el objeto base o maya.
			:2º Creamos la Armature y los huesos.
			:3º Renombramos los huesos
			:4º Creamos en la maya los grupos de vertices, Uno por cada hueso con el mismo nombre del hueso.
			:5º Damos los pesos a los grupos de vertices en la maya
			:6º Le decimos a la maya que su padre es la Armature.
			:NT: Asegurarse de que los huesos y la maya esten aplicadas todas las deformaciones y rotaciones.
			:-AUTOMATICO
			:1º Creamos el objeto base o maya.
			:2º Creamos la Armature y los huesos.
			:3º Renombramos los huesos
			:4º Selecionamos la Maya y añadimos a la selecion los huesos.
			:5º Con Ctrl+P Emparentamos Maya a Armature con Pesos Automaticos.
			:Como se puede ver en el modo automatico genera los grupos y los pesos de forma automatica
			:de forma muy efectiva, eso que nos quitamos.
			:
		*CAST
			·20230725182114
			ª10129ª10130
			:Modifica una geometria deformandola inchandola o contrallendola segun una figura geometrica.
			:Le podemos indicar:
			:Shape - La figura a la que queremos que se intente igualar o deformar.
			:Axis - El eje que se deformara.
			:Factor - Fuerza de la deformacion
			:Radius - Radio desde el centro que afecta la deformacion.
			:Size - Tamaño de la deformacion (Se multiplica el Size por el Factor)
			:Size From Radius - Iguala Size a Radius para que sean iguales.
			:Vertex Group - Indica el grupos de vertices que sera o no afectado.
			:Object - Indica que objeto usara como referencia (El Eje de ese objeto en lugar del propio)
			:
		*CURVE
			·20230725182114
			ª10131ª10132
			:Permite modificar un objeto o un array de objetos estirandolos y ajustandolos
			:a una curva en un exe dado.
			:El podificador se aplica al objeto que queremos modificar y le asociamos
			:a una curva que nos servida de ayudante para darle forma.
			:Le indicaremos el eje que tomara como referencia.
			:y si queremos el grupo de vertices que se vera afectado.
			:
		*DISPLACE
			·20230725182114
			ª10133ª10134ª10135
			:Mermite desplazar los vertices de un objeto segun un mapa o imagen.
			:Este desplazamiento estara dado por el patron Claro/oscuro de dicha imagen.
			:Se suele usar un mapa de alturas especifico para crear rugosidad en un material
			:Podemos indicarle :
			:-Coordinates - que Tipo de coordenadas usara para el desplazamiento,
			:Locales , Globales, Del propio objeto o de la UV.
			:-Direction - El eje que desplazara los vertices X, Y , Z Segun la normal (Mapa de alturas)
			:especifico o segun el patron de colores de la imagen.(Cada paleta es un eje Roja=x Verde=y Azul=z)
			:-Strength - Fuerza del desplazamiento.
			:-MidLevel- Inica donde situa la zona media del desplazamiento.
			:-Vertex Group - Indica el grupo de vertices a modificar o a no modificar (Boton derecho en VertxGroup=
			:
		*HOOK
			·20230725182114
			ª10136ª10137ª10138ª10139ª10143
			:Este Modificador permite enganchar los vertices de la geometria de un objeto
			:y modificarla al modificar este objeto.
			:Tiene acceso rapido con CTRL + H en modo edicion.
			:1º Creamos un objeto (con suficiente geometrioa)
			:2º Creamos el objeto ayudante
			:3º Añadimos el modificador Hook al objeto.
			:4º le indicamos al modificador que se asocie con el objeto ayudante (Revisar Centros y escalas)
			:5º Selecionando el Objeto entramos en modo edicion y asignamos los vertices que modificara el Hook.
			:
		*LAPLACIAN DEFORM
			·20230725182114
			ª10140ª10141ª101421ª10143ª10144ª10145
			:Este Modificador intenta suabizar un grupo de vertices de modo que el salto
			:entre esos vertices modificados y sus cercanos no sea tan brusco.
			:1º Creamos un objeto con suficiente geometria.
			:2º Creamos un grupo de vertices que queremos que pueda modificar.
			:3º Añadimos el modificador y le asignamos ese grupo en "Anchor Weights".
			:4º Por ultimo Bindeamos el grupo.(esto marcara la forma original)
			:A partir de esta forma suavizara las modificaciones realizadas.
			:- Este Modificador consume muchos recursos OJO.
			:Tambien podemos usarlo junto con HOOK para ayudar en las modificaciones.
			:En el menu CTRL + H tenemos una opcion que nos permite añadir a la selecion
			:de vertices los grupos de vertices de un hook.
			:
		*LATTICE
			·20230725182114
			ª10146ª10147ª10148ª10149
			:LATTICE permite modificar un objeto segun otro objeto ayudante de forma definida.
			:Se basa en un objeto especial, un objeto LATTICE.
			:Este objeto es un cubo con subdibisiones segun necesitemos.
			:Podemos colocar los vertices de este Lattice al gusto y al pasarlo
			:por el objeto principal lo deformara segun le indiquemos.
			:El Modificador no tiene mucho.
			:-El Objeto Tipo Lattice que se usara como objeto ayudante.
			:-El Grupo de vertices que queremos que se afecte o que no se afecte.
			:-La fuerza con que queremos que se afecten los bertices del objeto Base.
			:La Chicha esta en el propio objeto Lattice.
			:Este Objeto tiene una pestaña propia y podremos indicarle.
			:- La resolucion o cantidad de sub divisiones del Lattice
			:- La Interpolacion usada para cada coordenada (calculo usado para X, Y o Z /U,V,W)
			:- Outside - Si solo genera maya Exteriro o tambien la interior
			:
		*MESH DEFROM
			·20230725182114
			:Este Mod funciona igual que el LATTICE pero en lugar de usar un objeto especial
			:usa cualquier objeto con cualquier geometria.
			:Por lo normal se copia el objeto, se le simplifica, se le configura como WareFrame
			:se escala y se usa para deformar al objeto principal.
			:Funcion adel mismo modo.
			:Se aplica sobre el objeto Base y se le dice en Object el nombre del objeto ayudante.
			:Luego le damos precision (alcance de cada vertice a deformar)
			:Y se Bindea para que tenga la referencia inicial
			:Tambien le podemos indicar un Vertex Group para que aplique o proteja un grupo de vertices.
			:Dynamic - Hace que si el modificador tiene muchos poligonos dibuje una version reducida.
			:Este modificador consume muchos recursos.
			:
		*SHRINKWARP (Envoltura Retractil)
			·20230725182114
			ª10155
			:Nos permite unir dos objetos ajustado los vertices de conexion
			:de la manera mas obtima pisible.
			:Se aplica sobre el objeto a unir y le indicamos el objeto al que
			:queremos que se una.
			:En el Objeto a unir le podemos indicar un grupo de vertices con
			:pesos para que sepa cuanto pueden deformarse.
			:Tenemos distintos parametros
			:- Warp Method (Metodo de deformacion)
			:- Snap Mode (Modo automatico) Modo de ajuste.
			:- Target (obejto al que pegar.)
			:- OffSet (Distancia a considerar)
			:- Grupo de vertices con pesos para ajuste preciso.
			:NT:Para un mejor ajuste mirar el nodificador (DATATRANSFER)
			:
		*SIMPLEDEFORM
			·20230725182114
			ª10030ª10031
			:Este deformador nos permite modificar la maya
			:de un objeto generando distintos efectos detorsion
			:podemos definir el efecto TWIST, BEND, TAPER o STRETCH
			:El angulo, el objeto origen, la dimension sobre la que aplicarlo
			:podemos definir limites obloquear el efecto en alguna dimension.
			:Los efectos simulan un tornado de distintas maneras
			:Rotando (Twist), Curvando (Bend), Agrandando(Taper) o Inflando (Stretch)
			:la maya de un objeto.
			:
		*Smooth
			·20230725170039
			ª100000
		*Smooth Corrective
			·20230725170039
			ª100000
		*Smooth Laplacian
			·20230725170039
			ª100000
		*Surface Deform
			·20230725170039
			ª100000
		*Warp
			·20230725170039
			ª100000
		*Wave
			·20230725170039
			ª100000
	*FISICAS (Phisics)
		·20230725170039
		*Cloth
			·20230725170039
		*Collision
			·20230725170039
		*Dynamic Paint
			·20230725170039
		*Explode
			·20230725170039
		*Fluid
			·20230725170039
		*Ocean
			·20230725170039
		*Particle Instance
			·20230725170039
		*Particle System
			·20230725170039
		*Soft Body
			·20230725170039
	*Decimate
		·20230725182114
		:Elimina vertices de un objeto intentando conservar la geometria
		:
	*Simple Deform
		·20230725182114
		:Permite realuzar modificaciones basicas a un objeto
		:como tornarlo alargarlo etc.
		:
*RIGGIN
	·20230725170039
	*Huesos (Armature)
		·20230725182114
		ª10000ª10001ª10002ª10003ª10004
		:-Creamos una "Armature"
		:-La armadura es un objeto especial representado como un hueso.
		:-Este OBJ tiene una escala, posicion y rotacion.
		:-Esta Armature seria como una lista de lineas (edges) con
		:dos vertices (0-1) y otras propiedades
		:-Entrando en modo "EDICION" podemos modificar la lista
		:de esos "Huesos" (edges) y su propiedades.
		:-Selecionando el Hueso "EXTRUIMOS" un Hueso para crear otros.
		:-Ten en cuenta que cada hueso tiene rotaciones independientes
		:que podemos modificar o alinear con un eje.
		:-El OBJ Base "ARMATURE" tiene unas propiedades que podemos
		:ver en el panel derecho.
		:-Los "HUESOS" tambien tiene sus propiedades.
		:Los huesos no tienen por que estar atados a su hueso padre ni estar
		:vinculado a el.
		:Al estar "Emparentado" copiara la rotacion y posicon del padre.
		:Al estar "Concetado" el Vtx
		:los "HUESOS" (MODO OBJETO) y las propias de un "HUESO"
		:independiente (MODO EDICION).
		:
	*Huesos 02 (Bones)
		·20230725182114
		ª10005ª10006
		:Los huesos son objetos que tienen dos vertices, pertenecen a la Armadura
		:y aunque por defecto se crean atados y emparentados unos
		:huesos con otros en forma de cadena, no es necesario que
		:esten ni vinculados ni emparentados.
		:- Para editar la estructura de la "ARMATURE"
		:tenemos que entrar en "EDIT MODE" de la "ARMATURE".
		:- Podemos añadir nuevos HUSESO selecionando un HUESO y
		:extruyendo (tecla E) de este modo el HUESO que creemos
		:estara VINCULADO y EMPARENTADO al HUESO selecionado.
		:-Tambien podemos duplicar un hueso (tecla May + D) de este modo
		:el HUESO estara EMPARENTADO pero NO VINCULADO al padre.
		:-Podemos controlar las propiedades de los HUESOS con el panel
		:BONE PROPERTIES.
		:-Podemos EMPARENTAR/VINCULAR tambien con las teclas (Alt+P/ Ctrl+P)
		:
	*Huesos (Simetrize)
		·20230725182114
		ª10007ª10008
		:-El blender tiene un ayudane que permite copiar una estructura de forma
		:simetrica, se llama SYMMETRIZE.(Edit Mode Menu ARMATURE/SYMMETRIZE)
		:Imaginemos una ARMATURE deun humano, podemos crear toda la estructura
		:del lado derecho y con SYMMETRIZE nos generara el lado Izquierdo.
		:- Para ello solo tenemos que nombrar los huesos terminados en R o L, F o B
		:si selecionas los huesos terminados en R te generara los L (o F y B o R y L)
		:
	*Huesos (IK)(Inverse Kinematics)
		·20230725182114
		ª10009ª10010ª10011ª10012
		:- Las "IK" o Inverse Kinematics (Cinematica Inversa) es un modificador que se aplica
		:sobre un hueso, y que afecta a un numero de huesos pero de forma inversa.
		:- Cuando creamos una estructura de huesos, por defecto se crean consecutivamente,
		:la pierna afecta a la espinilla y esta al tobillo etc.
		:Pero tenemos un modo de que al modificar el tobillo afecte a la espinilla y este a la pierna.
		:Para ello se usa un CONSTRAIN (Modificador) de IK.
		:Este modificador usa un hueso como ayudante para modificar las posiciones.
		:- En EDIT MODE
		:Selecionamos el hueso base (Ej: Tobillo_R)
		:Extruimos un hueso que sera el ayudante (IK_Tobillo_R)
		:Lo desenparentamos y desvinculamos (ALT+P)
		:Ahora en POSE MODE
		:Selecionamos el Hueso Base,
		:añadimos a la selecion el Hueso Ayudante
		:Presionamos (Ctrl + May + C) para añadir una CONSTRAIN
		:Selecionamos IK. Esto añadira a ese hueso base un limitador.
		:Podemos editar sus parametros en panel BONE CONSTRAIN PROPERTIES
		:Definimos el CHAIN LENGTH (Enlaces afectados)
		:el POLE ANGLE (Rotacion del eje)
		:Influencia , dureza etc.
		:NT. Esto tambien se puede hacer de forma manual añadiendolo y configurandolo
		:a mano.
		:
	*Huesos (Copy Rotation)
		·20230725182114
		ª10014
		:Existen muchos CONSTRAIN (Limitadores) Copiar Rotacion es otro de ellos
		:Estos modificadores se aplican en POSE MODE
		:Selecinamos el hueso que copiara la rotacion.
		:Añadimos a la selecion el hueso del que copiara la rotacion.
		:Presionamos CTRL+MAY +C para añadir la CONSTRAIN Copy Rotation
		:Configuramos los parametros en el panel de BONE CONSTRAIN PROPERTIES
		:podemos poner TARGET (Objetivo) y OWNER (Dueño) en LOCAL SPACE
		:o podemos modificar la INFLUENCE al gusto.
		:NT. Esto tambien se puede hacer de forma manual añadiendolo y configurandolo
		:a mano.
		:
	*Huesos (Limit Rotation)
		·20230725182114
		ª10015
		:Es otro CONSTRAIN (Limitadores)
		:Tambien se aplica en POSE MODE.
		:En este caso selecionamos el hueso a limitar.
		:Presionamos CTRL+MAY +C para añadir la CONSTRAIN Limit Rotation.
		:Configuramos los parametros en el panel de BONE CONSTRAIN PROPERTIES
		:podemos poner OWNER (Dueño) en LOCAL SPACE
		:podemos modificar la INFLUENCE al gusto.
		:podemos Limitar los ejes afectados y los grados, etc.
		:
	*Huesos (Deform)
		·20230725182114
		ª10016
		:Esta propiedad le indica a blender que considere este hueso
		:para calcular y asociar los vertices de la maya.
		:Si lo desactivamos, cuando asociemos la maya a la armadura
		:no tendra en cuenta este hueso.
		:Tambien configura alcance del hueso y de sus vertices para
		:las influencias sobre la maya.
		:
	*Huesos (Custom Shape)
		·20230725182114
		ª10017
		:Esta opcion modifica el objeto que representa un hueso.
		:En OBJECT MODE creamos el objeto que queramos usar.
		:Selecionamos la ARMATURE
		:Entramos en POSE MODE
		:Selecionamos culaquier hueso que queramos modificar su
		:imagen, (IK_Mano_R).
		:En las propiedades del hueso buscamos la opcion CUSTOM SHAPE
		:y en CUSTOM OBJECT selecionamos el objeto que hemos creado
		:antes para que lo use.
		:Esto se usa para que cuando el riggeo este completo podamos
		:ocultar todos los huesos y dejando solo los ayudantes de forma mas
		:visible.
		:
	*Maya (Asociando)
		·20230725182114
		ª10018
		:Ahora en OBJECT MODE creamos el objeto que queremos
		:modificar con la ARMATURE.
		:El ARMATURE es un modificador de un objeto normal asociando a la maya
		:con la ARMATURE.
		:Lo podemos hacer de modo manula tambien, emparentando la maya a la ARMATURE
		:y añadiendo a la maya la ARMATURE.
		:Se suele hacer de modo automatico mejor.
		:Selecinamos primero la ARMATURE añadimos con MAY el objeto a modificar.
		:Añadimos el Modificador, presionamos (CTRL + P) esto nos dara distintas
		:opciones para asociar el objeto con una ARMATURE.
		:-Armature Deform
		:With Emtpy Groups
		:with Envelope Weights
		:with Automatic Weighs
		:
	*Maya (Deformacion)
		·20230725182114
		ª10019ª10020
		:El Riggeo consiste en crear un esqueleto y con el modificar una maya.
		:Imaginemos un humano donde modificando un dedo se modifique
		:la maya del dedo.
		:Al asociar la maya a la ARMATURE se crean grupos de vertices
		:EN LA MAYA con el nombre de cada hueso.
		:Esos grupos de vertices, el modificador ARMATURE se encarga de eso
		:al mover/rotar/deformar un hueso el modificador mira el grupo de vertices
		:de la maya con el nombre del hueso y usando los pesos de cada vertice
		:modifica este vertice de la maya.
		:Cada vertice tiene un numero "WEIGHT" o Peso que le indica la intensidad
		:con respecto a los vertices que le rodean ajustando su tension de deformacio.
		:Al Asociar la maya con la Armature puede
		:No crear grupos.
		:Crear gurpos vacios
		:Grear grupos y añadirles vertices por proximidad
		:Grear grupos y añadirles vertices por proximidad y calcular el peso.
		:Para modificar los grupos de vertices podemos usar EDIT MODE de la maya
		:o podemos usar los modos expeciales WEIGHT PAINT donde nos pintara
		:los vertices de colores del grupo selecionado segun su peso y pintarlos.
		:
*FBX
	·20230725170039
	*- MIXAMO (FBX) a BLENDER
		·20230725182114
		:- Include
		:Costom Normal V
		:Custom Properties V
		:Import Enums as Strings V
		:Image Search V
		:-Transform
		:Scale	1
		:Decal Offset	0
		:Use Pre/Post Rotation	V
		:- Manual Orienta	V
		:Forward	-Z
		:Up		+Y
		:-Animation	V
		:Animation OffSet	0
		:-Armature
		:Primary Bone Axis	Y
		:Secundary Bone Axis	-Z
		:
	*- BLENDER (FBX) a Unreal (Armatur y Mesh)
		·20230725182114
		:Blender (V 3.3.2)
		:- Include
		:Selected Objects V
		:Armature + Mesh
		:-Transform
		:Scale = 1
		:Apply Scaling = All Local
		:Forward = -Z Forward
		:Up = Y Up
		:- Geometry
		:Smoothing = Face
		:Apply Modifiers = V
		:-Armature
		:Primary Bone Axis = Y
		:Secondary Bone Axis = X
		:Armature FBXNode Type = Null
		:Add Leaf Bones = V
		:-Bake Animations = X
		:Blender Version 3.XX
		:Ignore Leaf Bones	X
		:Force Connect Children	X
		:Automatico Bone Orientation X
		:Secundary Bone Axis	-Z
		:- Bake Animation = X
		:Blender Version X
		:- Manual Orienta	V
		:Forward = -Z
		:Up = +Y
		:-Animation	V
		:Animation OffSet	0
		:
	*- BLENDER (FBX) a Unreal (Animation)
		·20230725182114
		:Blender (V 3.XX)
		:- Include
		:Selected Objects V
		:Armature
		:-Transform
		:Scale	1
		:Apply Scaling: All Cocal
		:Forware Y
		:Up Z
		:Apply Units V
		:-Geometry
		:Smoothing: Face
		:Apply Modifiers: V
		:- Armature
		:Primary : Y
		:Second : X
		:Arm FBXn Type : Null
		:-Bake Animation : V
		:Key All Bones : V
		:Force Star/End Keying : V
		:Sam..: 1 Simpl..:1
		:
	*- UNREAL IMPORT FBX del Blender (Animacion)
		·20230725182114
		:Para importar un Fbx con una animacion del Blender al UE
		:Boton import.
		:- Animation
		:Selecionamos el fbx
		:Nos tiene que autoselecioanr el Skeleton
		:Animation Lenght : Exported Time.
		:Import Bone Tracks : V
		:Delete Existing Morph : V
		:- Transform
		:- Miscellan
		:Convert Scene : V
		:Convert Scene Units : V
		:
*[ EJEMPLOS ]
	·20230725170039
	*Tela Realista
		·20230725170039
*[ GEOMETRY NODES ]
	·20230725170039
	*GEOMETRY
		·20230725170039
	*POINT
		·20230725182114
		ª10162
		:Crea puntos en distintos origenes.
		:- Distribute points on Faces
		:Crea un punto por cada cara en una posicion de la cara aleatoria.
		:- Point
		:- Point To Vertices
		:- Points To Volume
		:- Set Point Radius.
		:
	*MESH PRIMITIVES
		·20230725182114
		ª10160ª10161
		:Contiene las privitivas basicas.
		:- CONE
		:Crea un cono donde definiremos
		:El radio Inf , el Radio Sup, el Alto, los Segmentos,
		:Numero de vertices y el tipo de tapa
		:- CUBE
		:Crea un cubo donde definiremos
		:Alto, Ancho, Fondo, y las subdivisiones para alto , ancho y fondo.
		:- CYLINDER
		:Genera un cilindro donde podemos definir
		:el Radio, Numero de Vertices exteriores, Tipo de tapas, Altura.
		:- GRID
		:Genera un plano cuadrado de X x Y vertices y una separacion
		:X e Y entre ellos.
		:- ICO SPHERE
		:Genera una esfera triangulada de X subdivisiones y R Radio.
		:- MESH CIRCLE
		:Genera un circulo plano de X vertices y R Radio pudiendo
		:cerrarlo con una cara o multiples caras.
		:- MESH LINE
		:Traza una linea con X vertices desde punto A al B o un numero de
		:saltos de distancia dada.
		:- UV SPHERE
		:Genera una esfera con maya cuadrada donde definiremos
		:Radio, Segmentos y anillos.
		:
	*[ EJEMPLO ]
		·20230725170039
	*[ TUTORIAL ]
		·20230725182114
		ª10156ª10157ª10158
		:Se trata de poder crear objetos y modificarlos por nodos.
		:Este arbol de modificadores se puede aplicar a cualquer objeto para modificarlo mas tarde.
		:Para acceder tenemos la plantilla "Geomety Nodes"
		:esta plantilla nos muestra:
		:- "3D ViewPort"
		:- "SpreadSheed"
		:- "Geometry Nodes Editor"
		:3D ViewPort ya la conocemos.
		:SpreadSheed (presenta propiedades y datos del objeto creado)
		:Geomety Nodes Editor (Se editan las propiedades del objeto por nodos)
		:1º crearemos un objeto.
		:2º En "GNE" le añadimos un modificador de geometria por nodos.
		:Podemos apreciar que aunque para crear el "GN" se
		:asocia a un objeto realmente por dentro los trabaja como "Nodes Groups"
		:sin asociacion.
		:Tambien podemos ver que se trata de un modificador por lo
		:que se puede aplicar a cualqueir objeto.
		:Nos crea un nodo de entrada y un nodo de salida.
		:-El "Group Input" seria la geometria basica del objeto realcionado
		:que podemos editar o remplazar por otra.
		:-El "Group Output" es el nodo de salida resultante.
		:todo lo conectado a este nodo sera creado o modificado.
		:Podemos eliminar el "Group Input" y poner en su lugar otro objeto.
		:Cada objeto es una funcion que genera ese objeto.(una macro)
		:
*PYTON
	·20230728141152
	:#Importamos la libreria "bpy" Blender Pyton
	:import bpy
	:#Creamos una clase llamada Test_Panel
	:#a esta clase le pasamos una estructura tipo Panel.
	:#y configuramos el label=nombre idname=Identificador
	:#space_type= pantalla donde estara.
	:#region_type= Subpantalla donde estara.
	:#category = Secion o categoria donde estara.
	:#Si Categoria no existe la crea.
	:#En la pantalla de INFO podemos ver el nombre de las pantallas.
	:# PROPERTIES.WINDOW.scene
	:# VIEW_3D.UI.
	:class ClsMyPanel(bpy.types.Panel):
	:bl_label="Test Panel"
	:bl_idname = "PT_TestPanel"
	:bl_space_type = 'VIEW_3D'
	:bl_region_type = 'UI'
	:bl_category = "NewTab"
	:# Ahora en la clase definimos un drawin sobre el self (si mismo)
	:#creamos un row del tipo layout.row y definimos el titulo del row
	:#definiendo el texto como SampleTxt y un icono cube.
	:def draw(self, context):
	:layout=self.layout
	:row=layout.row()
	:row.label(text="SampleTxt", icon="cube")
	:def register():bpy.utils.register_class(LayoutDemoPanel)
	:def unregister():bpy.utils.unregister_class(LayoutDemoPanel)
	:if __name__ == "__main__": register()
	:
	*Caracteristicas de Payton
		·20230725182114
		:#Es Case Sensitive.
		:#Usa tabs para saber que esta dentro de una funcion o clase.
		:# Comentario linea
		:""" Comentario multi linea."""
		:#pass sigue la ejecucion sin dar error.
		:# - - - Definimos un bucle for.
		:for num in range(10):
		:if num == 8: pass
		:print(f"numero es {num}")
		:# - - - Definimos un bucle While
		:while MiCont<5:MiCont=MiCont+1
		:else:pass
		:if self.layout_type in {'DEFAULT', 'COMPACT'}:pass
		:elif self.layout_type=='GRID':pass
		:# - - - -Definimos una funcion Par2 Valor predefinido.
		:def NomFuncion(Par1,Par2="ss"):
		:contenido
		:return 0
		:#es posible pasarle los parametros directos o
		:#indicando el nombre de parametro.
		:NomFuncion(Par2="kk",Par1="TT")
		:NomFuncion("kk","TT")
		:#- - - - Definicion de clases
		:class NomCls:
		:def __init__(self, realpart, imagpart):
		:self.r = realpart
		:self.i = imagpart
		:X=NomCls(10,20)
		:print(X.r,X.i)
		:
	*Modificar Nombre de un hueso
		·20230725182114
		:Modificar el nobre de un hueso
		:import bpy
		:# Seleccionar el esqueleto
		:armature = bpy.data.objects['Armature']
		:# Seleccionar el hueso que deseas renombrar
		:bone = armature.pose.bones['Hueso']
		:# Cambiar el nombre del hueso
		:bone.name = 'Nuevo_Nombre'
		:
	*Mostrar los huesos de un esqueleto
		·20230725182114
		:import bpy
		:# Seleccionar el esqueleto
		:armature = bpy.data.objects['Armature']
		:# Recorrer todos los huesos del esqueleto y establecer su propiedad "hide" a False
		:for bone in armature.data.bones:
		:bone.hide = False
		:
	*Mostrar los grupos de Vertices de una maya
		·20230725182114
		:import bpy
		:# Seleccionar el objeto que contiene los grupos de vértices
		:obj = bpy.context.active_object
		:# Recorrer todos los grupos de vértices del objeto e imprimir su nombre y los vértices asociados
		:for group in obj.vertex_groups:
		:print("Grupo:", group.name)
		:for index, vertex in group.weight_group:
		:print("Vértice:", index, "Peso:", vertex)
		:
	*Modificar los nombres de los grupos de vertices de una maya
		·20230725182114
		:import bpy
		:# Seleccionar el objeto que contiene los grupos de vértices
		:obj = bpy.context.active_object
		:# Seleccionar el grupo de vértices que deseas renombrar
		:group = obj.vertex_groups['Nombre del grupo']
		:# Cambiar el nombre del grupo de vértices
		:group.name = 'Nuevo_Nombre'
		:
	*Modificar Nombres de huesos y grupos de vertices
		·20230725182114
		:Como modificar los nombres de los grupos de vertices y los nombres
		:de los huesos de la armadura asociada a ese objeto para que cada
		:nombre de hueso sea igual al grupo de vertices asociado a el?
		:import bpy
		:# Seleccionar el objeto que contiene los grupos de vértices
		:obj = bpy.context.active_object
		:# Recorrer todos los grupos de vértices del objeto y cambiar el nombre del grupo y el hueso asociado
		:for group in obj.vertex_groups:
		:# Cambiar el nombre del grupo de vértices
		:old_name = group.name
		:new_name = "Bone_" + old_name # Cambia esto según el prefijo que quieras usar para los huesos
		:group.name = new_name
		:# Obtener el hueso asociado al grupo de vértices
		:bone = obj.pose.bones.get(old_name)
		:if bone is not None:
		:# Cambiar el nombre del hueso
		:bone.name = new_name
		:
	*Listar los nombres de las acciones
		·20230725182114
		:Este código obtiene una lista de todas las acciones en la escena
		:actual y luego las recorre para imprimir el nombre de cada acción.
		:import bpy
		:# Obtener todas las acciones en la escena actual
		:actions = bpy.data.actions
		:# Imprimir el nombre de cada acción
		:for action in actions:
		:print(action.name)
		:
	*Renombrar nombre de una Accion
		·20230725182114
		:Obtenemos la acción que queremos renombrar utilizando el
		:método "get" en "bpy.data.actions".
		:Si la acción existe (no es "None"), cambiamos su nombre
		:utilizando el método "name".
		:import bpy
		:# Obtener la acción que quieres renombrar
		:action = bpy.data.actions.get("NombreActualDeLaAccion")
		:if action is not None:
		:# Cambiar el nombre de la acción
		:action.name = "NuevoNombreDeLaAccion"
		:
	*Remplazar palabra del nombre de un hueso
		·20230725182114
		:En este ejemplo, obtenemos el objeto de armadura y la armadura
		:asociada a ese objeto. Luego, recorremos cada hueso en la armadura y
		:utilizamos el método "replace" de Python para eliminar la
		:palabra "Eliminar" del nombre del hueso.
		:import bpy
		:# Obtener el objeto de armadura
		:armature_obj = bpy.data.objects["NombreDeLaArmadura"]
		:# Obtener la armadura del objeto
		:armature = armature_obj.data
		:# Recorrer los huesos y eliminar la palabra "Eliminar" del nombre
		:for bone in armature.bones:
		:bone.name = bone.name.replace("Eliminar", "")
		:
	*Crear un hueso en un esqueleto
		·20230725182114
		:Creamos los huesos de una mano.
		:import bpy
		:# Crear el objeto de armadura
		:armature_obj = bpy.data.objects.new("Esqueleto", bpy.data.armatures.new("Esqueleto"))
		:# Agregar el objeto de armadura a la escena
		:bpy.context.scene.collection.objects.link(armature_obj)
		:# Obtener la armadura del objeto
		:armature = armature_obj.data
		:# Crear los huesos de la columna vertebral
		:spine = ["Pelvis", "Cadera", "Columna baja", "Columna media", "Columna alta", "Cuello", "Cabeza"]
		:for i, bone_name in enumerate(spine):
		:bone = armature.edit_bones.new(bone_name)
		:bone.head = (0, 0, i*2)
		:bone.tail = (0, 0, (i+1)*2)
		:# Crear los huesos de los brazos
		:arms = ["Hombro izquierdo", "Codo izquierdo", "Muñeca izquierda", "Hombro derecho", "Codo derecho", "Muñeca derecha"]
		:for i, bone_name in enumerate(arms):
		:bone = armature.edit_bones.new(bone_name)
		:bone.head = (i*2, 0, 10)
		:bone.tail = ((i+1)*2, 0, 10)
		:# Crear los huesos de las piernas
		:legs = ["Cadera izquierda", "Rodilla izquierda", "Tobillo izquierdo", "Cadera derecha", "Rodilla derecha", "Tobillo derecho"]
		:for i, bone_name in enumerate(legs):
		:bone = armature.edit_bones.new(bone_name)
		:bone.head = (i*2, 0, 0)
		:bone.tail = ((i+1)*2, 0, 0)
		:# Actualizar la armadura
		:armature.update()
		:import bpy
		:# Crear el objeto de armadura
		:armature_obj = bpy.data.objects.new("Mano", bpy.data.armatures.new("Mano"))
		:# Agregar el objeto de armadura a la escena
		:bpy.context.scene.collection.objects.link(armature_obj)
		:# Obtener la armadura del objeto
		:armature = armature_obj.data
		:# Crear los huesos de la mano
		:bones = ["Wrist", "Thumb0", "Thumb1", "Thumb2", "Index0", "Index1", "Index2", "Middle0", "Middle1", "Middle2", "Ring0", "Ring1", "Ring2", "Pinky0", "Pinky1", "Pinky2"]
		:bone_head_positions = [(0, 0, 0), (0, 1, 0), (0.5, 1, 0), (1, 1, 0), (0, 2, 0), (0.5, 2, 0), (1, 2, 0), (0, 3, 0), (0.5, 3, 0), (1, 3, 0), (-0.5, 2, 0), (-1, 2, 0), (-1.5, 2, 0), (-0.5, 3, 0), (-1, 3, 0), (-1.5, 3, 0)]
		:for i, bone_name in enumerate(bones):
		:bone = armature.edit_bones.new(bone_name)
		:bone.head = bone_head_positions[i]
		:if i == 0:
		:bone.tail = (0, 0, 1)
		:else:
		:bone.tail = bone_head_positions[i-1]
		:# Parenting de los huesos
		:armature.edit_bones["Thumb0"].parent = armature.edit_bones["Wrist"]
		:armature.edit_bones["Index0"].parent = armature.edit_bones["Wrist"]
		:armature.edit_bones["Middle0"].parent = armature.edit_bones["Wrist"]
		:armature.edit_bones["Ring0"].parent = armature.edit_bones["Wrist"]
		:armature.edit_bones["Pinky0"].parent = armature.edit_bones["Wrist"]
		:armature.edit_bones["Thumb1"].parent = armature.edit_bones["Thumb0"]
		:armature.edit_bones["Thumb2"].parent = armature.edit_bones["Thumb1"]
		:armature.edit_bones["Index1"].parent = armature.edit_bones["Index0"]
		:armature.edit_bones["Index2"].parent = armature.edit_bones["Index1"]
		:armature.edit_bones["Middle1"].parent = armature.edit_bones["Middle0"]
		:armature.edit_bones["Middle2"].parent = armature.edit_bones["Middle1"]
		:armature.edit_bones["Ring1"].parent = armature.edit_bones["Ring0"]
		:armature.edit_bones["Ring2"].parent = armature.edit_bones["Ring1"]
		:armature.edit_bones["Pinky1"].parent = armature.edit_bones["Pinky0"]
		:armature.edit_bones["Pinky2"].parent = armature.edit_bones["Pinky1"]
		:# Actualizar la armadura
		:armature.update()
		:
	*Crear una maya en a un hueso de la mano
		·20230725182114
		:Creamos los vertices de la maya de
		:import bpy
		:# Crea una malla de mano vacía
		:bpy.ops.mesh.primitive_cube_add(location=(0,0,0))
		:bpy.ops.transform.resize(value=(0.3, 0.2, 0.5))
		:# Selecciona la malla de la mano y entra al modo de edición
		:bpy.ops.object.mode_set(mode='EDIT')
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.object.mode_set(mode='OBJECT')
		:# Seleccióna los vértices para esculpir la mano
		:bpy.ops.object.mode_set(mode='EDIT')
		:bpy.ops.mesh.select_mode(type='VERT')
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.mesh.select_circle(x=0, y=0, radius=0.4)
		:bpy.ops.mesh.select_circle(x=0, y=1, radius=0.4)
		:bpy.ops.mesh.select_circle(x=0, y=-1, radius=0.4)
		:bpy.ops.mesh.select_circle(x=1, y=0, radius=0.4)
		:bpy.ops.mesh.select_circle(x=-1, y=0, radius=0.4)
		:# Escale la selección para crear la palma de la mano
		:bpy.ops.transform.resize(value=(0.5, 1.2, 1))
		:# Seleccione los bordes y caras necesarios para esculpir los dedos de la mano
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.mesh.select_circle(x=0.8, y=0, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=-0.8, y=0, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0, y=1.2, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0, y=-1.2, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0.6, y=1, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=-0.6, y=1, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0.6, y=-1, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=-0.6, y=-1, radius=0.25, gesturemode=3)
		:# Extruir los bordes para crear los dedos
		:bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value":(0, 0.2, 0)})
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.mesh.select_circle(x=0.8, y=0, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=-0.8, y=0, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0, y=1.2, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0, y=-1.2, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=0.6, y=1, radius=0.25, gesturemode=3)
		:bpy.ops.mesh.select_circle(x=-0.
		:Breve explicación de cómo puedes crear una mano humana
		:en Blender utilizando Python:
		:Crea un objeto de malla de mano:
		:Puedes crear un objeto de malla de mano utilizando la clase Mesh de Blender. La clase Mesh tiene varias funciones y propiedades que te permiten crear y manipular mallas, incluidas las mallas de mano.
		:Configura la topología de la mano:
		:Una vez que hayas creado el objeto de malla de mano, necesitarás configurar la topología de la mano. Esto incluye la creación de los bordes, caras y vértices necesarios para definir la forma de la mano.
		:Ajusta la forma de la mano:
		:Después de configurar la topología de la mano, debes ajustar la
		:forma de la mano para que se parezca a una mano humana realista.
		:Esto puede implicar la manipulación de los vértices y bordes para
		:dar forma a la mano.
		:Agrega detalles: Después de ajustar la forma básica de la mano,
		:puedes agregar detalles como los pliegues de la piel y las uñas.
		:También puedes agregar texturas para hacer que la mano se vea
		:más realista.
		:Es importante tener en cuenta que crear una mano humana realista
		:en Blender puede ser un proceso largo y complicado, incluso con la
		:ayuda de Python. Sin embargo, hay muchos recursos en línea que
		:pueden ayudarte a aprender a hacerlo. ¡Buena suerte!
		:me podrias enseñar los comandos en pyton para crear la mano que se usan?
		:import bpy
		:import bmesh
		:# Crear un nuevo objeto de malla de mano
		:hand_mesh = bpy.data.meshes.new("hand_mesh")
		:hand_obj = bpy.data.objects.new("hand_obj", hand_mesh)
		:bpy.context.collection.objects.link(hand_obj)
		:# Crear una malla de mano básica
		:bm = bmesh.new()
		:v1 = bm.verts.new((-1.0, -0.5, 0.0))
		:v2 = bm.verts.new((1.0, -0.5, 0.0))
		:v3 = bm.verts.new((1.0, 0.5, 0.0))
		:v4 = bm.verts.new((-1.0, 0.5, 0.0))
		:v5 = bm.verts.new((0.0, 0.0, 1.0))
		:bm.faces.new((v1, v2, v3, v4))
		:bm.faces.new((v1, v5, v4))
		:bm.faces.new((v2, v5, v3))
		:bm.faces.new((v1, v2, v5))
		:bm.faces.new((v2, v3, v5))
		:bm.faces.new((v3, v4, v5))
		:bm.faces.new((v4, v1, v5))
		:bm.to_mesh(hand_mesh)
		:bm.free()
		:# Aplicar un modificador de subdivisión para suavizar la malla de mano
		:subsurf = hand_obj.modifiers.new('subsurf', 'SUBSURF')
		:subsurf.levels = 2
		:# Seleccionar el objeto de la mano
		:bpy.context.view_layer.objects.active = hand_obj
		:# Cambiar a modo de edición
		:bpy.ops.object.mode_set(mode='EDIT')
		:# Seleccione un borde en la muñeca
		:bpy.ops.mesh.select_mode(type='EDGE')
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.mesh.select_loops(extend=False)
		:bpy.ops.mesh.select_more()
		:# Extrusión del borde para crear la palma de la mano
		:bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value": (0, 0, -0.5)})
		:# Seleccione un borde en la base del dedo
		:bpy.ops.mesh.select_all(action='DESELECT')
		:bpy.ops.mesh.select_loops(extend=False)
		:bpy.ops.mesh.select_more()
		:bpy.ops.mesh.select_more()
		:bpy.ops.mesh.select_more()
		:# Extrusión del borde para crear el dedo
		:bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value": (0.5, 0, 0)})
		:# Repetir el proceso de extrusión y selección para crear los demás dedos y la palma de la mano.
		:# Cambiar de nuevo al modo de objeto
		:bpy.ops.object.mode_set(mode='OBJECT')
		:
	*Tambien modificar las animaciones
		·20230725182114
		:Renombrar los huesos de un esqueleto y los grupos de vértices de una
		:malla asociada a ese esqueleto en Blender,
		:python
		:Copy code
		:import bpy
		:def rename_bones_and_vertex_groups():
		:# Nombre actual y nuevo de los huesos
		:nombre_actual = "NombreActual" # Reemplaza esto con el nombre actual del hueso
		:nombre_nuevo = "NombreNuevo" # Reemplaza esto con el nombre nuevo del hueso
		:# Obtenemos el objeto del esqueleto
		:esqueleto_obj = bpy.data.objects.get("NombreDelEsqueleto") # Reemplaza esto con el nombre de tu objeto de esqueleto
		:if esqueleto_obj is None or esqueleto_obj.type != 'ARMATURE':
		:print("No se encontró el objeto de esqueleto o el objeto no es un esqueleto.")
		:return
		:# Renombramos los huesos
		:for bone in esqueleto_obj.data.bones:
		:if nombre_actual in bone.name:
		:bone.name = bone.name.replace(nombre_actual, nombre_nuevo)
		:# Renombramos los grupos de vértices de la malla asociada al esqueleto
		:malla_asociada = bpy.data.meshes.get("NombreDeLaMallaAsociada") # Reemplaza esto con el nombre de tu malla asociada
		:if malla_asociada:
		:for group in malla_asociada.vertex_groups:
		:if nombre_actual in group.name:
		:group.name = group.name.replace(nombre_actual, nombre_nuevo)
		:# Actualizamos las referencias a los grupos de vértices en la malla asociada
		:bpy.context.view_layer.objects.active = esqueleto_obj
		:bpy.ops.object.mode_set(mode='EDIT')
		:bpy.ops.object.mode_set(mode='OBJECT')
		:bpy.ops.object.select_all(action='DESELECT')
		:esqueleto_obj.select_set(True)
		:bpy.context.view_layer.objects.active = esqueleto_obj
		:bpy.ops.object.mode_set(mode='WEIGHT_PAINT')
		:if __name__ == "__main__":
		:rename_bones_and_vertex_groups()
		:Asegúrate de reemplazar los valores de nombre_actual, nombre_nuevo, "NombreDelEsqueleto" y "NombreDeLaMallaAsociada" con los nombres adecuados de tu esqueleto y malla asociada. Ejecuta este script en el editor de texto de Blender mientras tienes el archivo con el esqueleto y la malla abierto.
		:Recuerda que este script renombrará todos los huesos y grupos de vértices que contengan el nombre especificado en nombre_actual. Asegúrate de que los nombres sean únicos y distintivos para evitar problemas.
		:Si no estás familiarizado con la programación en Python o la API de Blender, puede ser útil revisar la documentación oficial de Blender y la documentación de Python para comprender mejor cómo funcionan las operaciones de renombrado y manipulación de objetos. ¡Buena suerte!
		:Si necesitas reemplazar el nombre de los huesos en todas las acciones (animaciones) de Blender, podemos ajustar el script para que también realice esa tarea. Aquí tienes la versión actualizada:
		:python
		:Copy code
		:import bpy
		:def rename_bones_in_actions():
		:# Parte del nombre del hueso que quieres reemplazar
		:parte_a_reemplazar = "ParteAReemplazar" # Reemplaza esto con la parte del nombre del hueso que deseas cambiar
		:texto_a_reemplazar = "TextoAReemplazar" # Reemplaza esto con el texto que deseas utilizar como reemplazo
		:# Obtenemos el objeto del esqueleto
		:esqueleto_obj = bpy.data.objects.get("NombreDelEsqueleto") # Reemplaza esto con el nombre de tu objeto de esqueleto
		:if esqueleto_obj is None or esqueleto_obj.type != 'ARMATURE':
		:print("No se encontró el objeto de esqueleto o el objeto no es un esqueleto.")
		:return
		:# Renombramos los huesos en todas las acciones
		:for action in bpy.data.actions:
		:for fcurve in action.fcurves:
		:data_path = fcurve.data_path
		:if parte_a_reemplazar in data_path:
		:fcurve.data_path = data_path.replace(parte_a_reemplazar, texto_a_reemplazar)
		:# Renombramos los huesos
		:for bone in esqueleto_obj.data.bones:
		:if parte_a_reemplazar in bone.name:
		:bone.name = bone.name.replace(parte_a_reemplazar, texto_a_reemplazar)
		:# Renombramos los grupos de vértices de la malla asociada al esqueleto
		:malla_asociada = bpy.data.meshes.get("NombreDeLaMallaAsociada") # Reemplaza esto con el nombre de tu malla asociada
		:if malla_asociada:
		:for group in malla_asociada.vertex_groups:
		:if parte_a_reemplazar in group.name:
		:group.name = group.name.replace(parte_a_reemplazar, texto_a_reemplazar)
		:# Actualizamos las referencias a los grupos de vértices en la malla asociada
		:bpy.context.view_layer.objects.active = esqueleto_obj
		:bpy.ops.object.mode_set(mode='EDIT')
		:bpy.ops.object.mode_set(mode='OBJECT')
		:bpy.ops.object.select_all(action='DESELECT')
		:esqueleto_obj.select_set(True)
		:bpy.context.view_layer.objects.active = esqueleto_obj
		:bpy.ops.object.mode_set(mode='WEIGHT_PAINT')
		:if __name__ == "__main__":
		:rename_bones_in_actions()
		:Ahora, este script también renombrará los huesos en todas las acciones de la escena de Blender. Asegúrate de reemplazar ParteAReemplazar con la parte específica del nombre del hueso que deseas cambiar y TextoAReemplazar con el texto que deseas utilizar como reemplazo.
		:Recuerda guardar tu archivo de Blender antes de ejecutar el script y tener seleccionado el objeto del esqueleto y la malla asociada antes de ejecutarlo para que funcione correctamente.
		:Si tienes alguna otra pregunta o necesitas más ayuda, no dudes en preguntar. ¡Espero que este script sea útil para tu trabajo con Blender!
		:
	*NEW
		·20230725170039
