{WinHelper V2.00 by FNX A1 2024}
{WIN_W}00541
{JPG_SIZE}00068
{IMG_AUTO}10000
{WIN_DESC_H}00488
{WIN_DESC_PIC_H}00109
{WIN_EDT_GRP_H}00306
{WIN_ALING_LEFT}00001
{WIN_IMG_CFG}.0199.0254.0586.0583.0055
{LAT_H}00030
{LAT_W}00010
{LAT_C}255255000
*00- GODOT
	:Cursos Online
	:https://godottutorials.com/
	:Video Tutorial.
	:https://www.youtube.com/watch?v=L3pFEk1HPCQ&list=PL5PTqiCIVoiVyA2qed1NE4uKejXEWM60e
	:https://docs.godotengine.org/es/4.x/classes/class_performance.html
	:-En la web oficial nos descargamos el motor.
	:https://godotengine.org/download/windows/
	:Tenemos dos versiones.
	:la primera esta pensada para usar GScript
	:La segunda .NET para usar C#.
	:No requiere instalacion simplemente es descargar y descomprimir
	:en una carpeta.
	:Segun lo abrimos nos presenta dos pestañas.
	:Proyectos Locales y Libreria de Assets.
	:Creamos un nuevo proyecto.
	:Le damos una carpeta.
	:Decidimos el tipo de motor grafico.
	:-Los dos primeros usan bulkan (opengl4)
	:-El modo compatible para equipos mas viejos usa (opengl3)
	:-Pretenden implementar DirectX13 pero aun no esta.
	:Decidimos si queremos control de versiones o no.
	:-Al nodo actual se accede con el comando "SELF"
	:igual al "THIS" en C#
	:print(self.name);
*Acceder a un nodo y sus propiedades
	ª10017
	:Tenemos tres modos de acceder a las propiedades de un
	:nodo.
	:-
	:Usando el comando get_node("Nombre Nodo");
	:-
	:Usando el simbolo $NOMBRENODO
	:-
	:Arrastra el nodo hasta el script para que el escriba el nombre.
	:-
	:- EJEMPLOS
	:# Called when the node enters the scene tree for the first time.
	:func _ready()->void:
	:·tvar M_Node=get_node("Ctr_Casa");
	:·t$Ctr_Casa.LAYOUT.clip_contents=true;
	:·tprint(F_Calcula());
	:·tpass # Replace with function body.
	:#FIN Func _Ready
	:# Called every frame. 'delta' is the elapsed time since the previous frame.
	:func _process(delta):
	:·t#print(delta);
	:·tpass
	:#FIN _Process
	:func F_Calcula()->Array:
	:·treturn [3,5,7];
	:·tpass
	:#Fin Funcion F_Calcula
*Acceso a los nodos1
	:Para obtener acceso a los nodos tenemos dos modos.
	:-
	:Podemos usar el comando get_node("Nombre Nodo")
	:o podemos usar $NombreNodo
	:-
	:Tambien puedes arrastrar un nodo y el godot te genera el acceso
	:E incluso las propiedades de los nodos.
*ACCIONES Y EVENTOS (Acciones)
	:En Godot la clase manejadora de los Inputs es
	:INPUTMAP que hereda de OBJECT.
	:-
	:InputMap:Object.
	:void·taction_add_event(action: StringName, event: InputEvent)
	:void·taction_erase_event(action: StringName, event: InputEvent)
	:void·taction_erase_events(action: StringName)
	:float·taction_get_deadzone(action: StringName)
	:Array[InputEvent]·taction_get_events(action: StringName)
	:bool·taction_has_event(action: StringName, event: InputEvent)
	:void·taction_set_deadzone(action: StringName, deadzone: float)
	:void·tadd_action(action: StringName, deadzone: float = 0.5)
	:void·terase_action(action: StringName)
	:bool·tevent_is_action(event: InputEvent, action: StringName, exact_match: bool = false) const
	:Array[StringName]·tget_actions()boolhas_action(action: StringName) const
	:void·tload_from_project_settings()
	:-
	:Por una parte tiene  las ACCIONES
	:posibles a realizar en el juego.
	:-
	:Y por otra parte tiene una lista de EVENTOS.
	:Los EVENTOS estan relacionados con las ACCIONES.
	:Una ACCION puede tener muchos EVENTOS.
	:-
	:var M_LstAcc=InputMap.get_actions();
	:var M_LstEvt=InputMap.action_get_events(M_LstAcc[0]);
	:-
	:Una ACCION tambien defina la zona muerta (deadzone)
	:en las entradas define la zona que no realizaran cambios.
	:Esto se entiende en los Pads que dan un valor float siendo
	:el Centro la posicon 0  y su valor float de -1 a 0 a +1
	:-
	:Los EVENTOS pueden ser de distintos tipos segun
	:el PERIFERICO del que toman los datos y del TIPO
	:de dato que capturan.
	:De este modo podemos tener para el JOYPAD o el MOUSE
	:dos TIPOS , (Botones y Ejes)
	:Los botones dan valor (0 o 1) y los ejes (-1 a 0 a +1)
	:-
*ACCIONES Y EVENTOS (Eventos)
	:Los INPUTEVENT es la clase que controla las entradas
	:de los perifericos al juego.
	:Los EVENTOS estan asociados a un Dispositivo (DEVICE)
	:y segun su tipo tendra distintos datos de entrada.
	:-
	:InputEvent<-Resource<-RefCounted<-Object
	:Propiedad
	:·tint device [def:0]
	:Metodos
	:bool·taccumulate(with_event: InputEvent)
	:String·tas_text() const
	:float·tget_action_strength(action: StringName, exact_match: bool = false) const
	:bool·tis_action(action: StringName, exact_match: bool = false) const
	:bool·tis_action_pressed(action: StringName, allow_echo: bool = false, exact_match: bool = false) const
	:bool·tis_action_released(action: StringName, exact_match: bool = false) const
	:bool·tis_action_type() const
	:bool·tis_canceled() const
	:bool·tis_echo() const
	:bool·tis_match(event: InputEvent, exact_match: bool = true) const
	:bool·tis_pressed() const
	:bool·tis_released() const
	:InputEvent·txformed_by(xform: Transform2D, local_ofs: Vector2 = Vector2(0, 0)) const
	:-
	:Los EVENTOS estan vivos y una vez definidos ya capturan el estado de
	:la entrada asociada.
	:-
	:Los EVENTOS pueden ser de distintos tipos segun el periferico que
	:enlazen.
	:Por lo que tendremos distintas clases segun el dispositivo y la accion.
	:-
	:InputEventAction
	:InputEventFromWindow
	:InputEventGesture
	:InputEventJoypadButton
	:InputEventJoypadMotion
	:InputEventKey
	:InputEventMagnifyGesture
	:InputEventMIDI
	:InputEventMouse
	:InputEventMouseButton
	:InputEventMouseMotion
	:InputEventPanGesture
	:InputEventScreenDrag
	:InputEventScreenTouch
	:InputEventShortcut
	:InputEventWithModifiers
	:-
	:Class:   InputEventKey
	:Inherits:   InputEventWithModifiers <   InputEventFromWindow <   InputEvent <   Resource <   RefCounted <   Object
	:- Properties
	:bool·techo [default: false]
	:Key·tkey_label [default: 0]
	:Keyk·teycode [default: 0]
	:Key·tphysical_keycode [default: 0]
	:bool·tpressed [default: false]
	:int·tunicode [default: 0]
	:- Methods
	:String·tas_text_key_label() const
	:String·tas_text_keycode() const
	:String·tas_text_physical_keycode() const
	:Key·tget_key_label_with_modifiers() const
	:Key·tget_keycode_with_modifiers() const
	:Key·tget_physical_keycode_with_modifiers() const
	:-
	:Class:   InputEventMouse
	:Inherits:   InputEventWithModifiers <   InputEventFromWindow <   InputEvent <   Resource <   RefCounted <   Object
	:- Properties
	:BitField[MouseButtonMask]·tbutton_mask [default: 0]
	:Vector2·t·t·tglobal_position [default: Vector2(0, 0)]
	:Vector2·t·t·tposition [default: Vector2(0, 0)]
	:-
	:Class:   InputEventMouseButton
	:Inherits:   InputEventMouse <   InputEventWithModifiers <   InputEventFromWindow <   InputEvent <   Resource <   RefCounted <   Object
	:- Properties
	:MouseButton·tbutton_index [default: 0]boolcanceled [default: false]
	:bool·t·tdouble_click [default: false]
	:float·t·tfactor [default: 1.0]
	:bool·t·tpressed [default: false]
	:-
	:Class:   InputEventMouseMotion
	:Inherits:   InputEventMouse <   InputEventWithModifiers <   InputEventFromWindow <   InputEvent <   Resource <   RefCounted <   Object
	:-Properties
	:bool·tpen_inverted [default: false]
	:float·tpressure [default: 0.0]
	:Vector2·trelative [default: Vector2(0, 0)]
	:Vector2·ttilt [default: Vector2(0, 0)]
	:Vector2·tvelocity [default: Vector2(0, 0)]
	:-
	:Class:   InputEventJoypadButton
	:Inherits:   InputEvent <   Resource <   RefCounted <   Object
	:- Properties
	:JoyButton·t·tbutton_index [default: 0]
	:bool·t·tpressed [default: false]
	:float·t·tpressure [default: 0.0]
	:-
	:Class:   InputEventJoypadMotion
	:Inherits:   InputEvent <   Resource <   RefCounted <   Object
	:- Properties
	:JoyAxis·taxis [default: 0]
	:float·taxis_value [default: 0.0]
*ARRAYS y DICCIONARIOS
	:Los ARRAYS,
	:Son listas de datos, cada celda puede ser de un tipo
	:de dato y guarda una posicion segun el orden de creacion.
	:-
	:var V_LstNom:Array=[
	:·t"Pedro",
	:·t26,
	:·t10.20,
	:·t20.30,
	:·tfalse,
	:·t[
	:·t·t"Fusco",
	:·t·t"cuchillo",
	:·t·t"ganzua"
	:·t]
	:]
	:-
	:Para acceder a los datos del array se usan los [ ]
	:-
	:print("Nombre ",V_LstNom[0]);# Nombre Pedro
	:print("Arma ",V_LstNom[5][1]);# Arma Cuchillo
	:-
	:Para saber el numero de elementos de un array se usa .size();
	:-
	:var M_LstAcc:Array=InputMap.get_actions();
	:for Mq in M_LstAcc.size():
	:-
	:-
	:Los DICIONARIOS
	:-
	:son como las arrays pero contienen "Clave Valor" ,
	:En los arrays la clave es la posicon que ocupa el dato
	:en el array y es atumatico.
	:En los dicionarios se define un nombre como clave y
	:se le da un valor.
	:Las claves no se pueden repetir.
	:-
	:var diccionario_principal = {};# Crear un diccionario principal
	:var mi_array = [1, 2, 3];# Crear un array
	:diccionario_principal["array"] = mi_array ;#Añadimos a dicionario el array
	:-
	:var diccionario_interno = {};# Crear un diccionario interno
	:diccionario_interno["nombre"] = "Ana"
	:diccionario_interno["edad"] = 25
	:-
	:# Agregar el diccionario interno al diccionario principal
	:diccionario_principal["diccionario"] = diccionario_interno
	:-
	:# Acceder a elementos dentro del diccionario principal
	:var array_recuperado = diccionario_principal["array"]
	:var diccionario_recuperado = diccionario_principal["diccionario"]
	:-
	:# Acceder a elementos dentro del diccionario interno
	:var nombre = diccionario_recuperado["nombre"]
	:var edad = diccionario_recuperado["edad"]
	:-
	:# Imprimir valores
	:print("Array:", array_recuperado)
	:print("Nombre:", nombre)
	:print("Edad:", edad)
	:-
	:Para saber si un item pertenece a una colecion existen dos metodos
	:con la funcion .has("KEY"); o con if("KEY" in Colecion):.
	:-
*AUTOLOAD o SINGLETON
	ª10018ª10019ª10020ª10023ª10021ª10022
	:Son script con funciones o variables que se
	:cargan de forma automatica al iniciar un proyecto.
	:-
	:Se cargan en memoria y se pueden usar desde
	:cualquier parte del juego por lo que son GLOBALES.
	:-
	:Para ello creamos un nuevo SCRIPT
	:Le damos un buen nombre.
	:Añadimos las funciones y variables que queremos que
	:sean GLOBALES.
	:Guardamos.
	:En el menu PROJECT entramos en PROJECT SETINGS
	:selecinamos la pestaña AUTOLOADS.
	:Selecionamos el o los SCRIPTs que queremos usar.
	:Le damos un NOMBRE
	:y los añadimos.
	:Definimos el orden de carga.
	:y Ya estan listos para usarse.
	:EJ:
	:Creamos un Script V.gd
	:Dentro creamos una variable V_SCORE:int;
	:Lo Añadimos en el auto load como GLOBAL.
	:y para usarlos solo necesitamos poner
	:GLOBAL.V_SCORE=XX;
*BUCLES
	:Los bucles son bloques de codigo que se repiten hasta
	:que una condicion o mientras una condicion se cumpla.
	:Tenemos dos tipos principalmente.
	:-
	:for VARIABLE in rangue(INI,FIN):
	:Este bucle se repite recorriendo una colecion para todos
	:los miembros de un grupo.
	:El comando range(1,10) genera un grupo de X elementos
	:que luego se recorren y dando a VARIABLE el valor del grupo.
	:La variable de control es creada no se puede predefinir y
	:se elimina fuera del for.
	:-
	:#Se puede usar para numeros
	:for V_PosX in range(1,10):
	:·tprint("PosX = ",V_PosX);
	:#Fin For PosX.
	:-
	:#Se puede usar con arrais para recorrerlos
	:var T_Frutas = ["Manzana","Pera","etc"];
	:for V_Fruta in T_Frutas:
	:·tprint(V_Fruta);
	:#Fin For Frutas.
	:-
	:#Este for carga un array de strings y lo recorre
	:var M_LstAcc:Array=InputMap.get_actions();
	:for Mq in M_LstAcc.size():
	:·tM_Acc=M_LstAcc[Mq];
	:·tprint(M_Acc)
	:#END For
	:-
	:Bucle WHILE (condicion)
	:Este bucle no recorre lista
	:Este bucle ejecuta un bloque de sentencias mientras que la
	:condicion se cumpla.
	:Para salir del bucle podemos o establecer la CONDICION a FALSA
	:o usar la sentencia BREAK
	:var Mq:int=0;
	:while (Mq<10):
	:_ print("Wile ",Mq);
	:_ Mq+=1;
	:#Fin del While
*CLASE - ARRAYS
	:#                  0        1  2     3
	:var array = ["One", 2, 3, "Four"]
	:-
	:var array1 = ["One", 2]
	:var array2 = [3, "Four"]
	:print(array1 + array2) # ["One", 2, 3, "Four"]
	:-
	:- - - - METODOS - - - -
	:bool·t·tall ( Callable method ) const
	:bool·t·tany ( Callable method ) const
	:void·t·tappend ( Variant value )
	:void·t·tappend_array ( Array array )
	:void·t·tassign ( Array array )
	:Variant·t·tback ( ) const
	:int·t·tbsearch ( Variant value, bool before=true ) const
	:int·t·tbsearch_custom ( Variant value, Callable func, bool before=true ) const
	:void·t·tclear ( )
	:int·t·tcount ( Variant value ) const
	:Array·t·tduplicate ( bool deep=false ) const
	:void·t·terase ( Variant value )
	:void·t·tfill ( Variant value )
	:Array·t·tfilter ( Callable method ) const
	:int·t·tfind ( Variant what, int from=0 ) const
	:Variant·t·tfront ( ) const
	:int·t·tget_typed_builtin ( ) const
	:StringName·tget_typed_class_name ( ) const
	:Variant·t·tget_typed_script ( ) const
	:bool·t·thas ( Variant value ) const
	:int·t·thash ( ) const
	:int·t·tinsert ( int position, Variant value )
	:bool·t·tis_empty ( ) const
	:bool·t·tis_read_only ( ) const
	:bool·t·tis_same_typed ( Array array ) const
	:bool·t·tis_typed ( ) const
	:void·t·tmake_read_only ( )
	:Array·t·tmap ( Callable method ) const
	:Variant·t·tmax ( ) const
	:Variant·t·tmin ( ) const
	:Variant·t·tpick_random ( ) const
	:Variant·t·tpop_at ( int position )
	:Variant·t·tpop_back ( )
	:Variant·t·tpop_front ( )
	:void·t·tpush_back ( Variant value )
	:void·t·tpush_front ( Variant value )
	:Variant·t·treduce ( Callable method, Variant accum=null ) const
	:void·t·tremove_at ( int position )
	:int·t·tresize ( int size )
	:void·t·treverse ( )
	:int·t·trfind ( Variant what, int from=-1 ) const
	:void·t·tshuffle ( )
	:int·t·tsize ( ) const
	:Array·t·tslice ( int begin, int end=2147483647, int step=1, bool deep=false ) const
	:void·t·tsort ( )
	:void·t·tport_custom ( Callable func )
	:-
	:.ALL() , .ANY()
	:Evalua todos los datos del array y retorna TRUE o FALSE si se cumple
	:TODO o ALGUNA condicion en cada elemento
	:-
	:print([4, 8, 6].any( func (number): return number > 5 ) );# no, si , si = True
	:print([4, 4, 4].any( func (number): return number > 5 ) );# no, no, no = False
	:print([4, 8, 6].all( func (number): return number > 5 ) );# no, si , si = False
	:print([8, 9, 6].all( func (number): return number > 5 ) );# si, si, si = True
	:print( [6, 10, 6].all(F_MayorQue5) );# si,si,si= True
	:func F_MayorQue5(number):return (number > 5);
	:-
	:.SORT_CUSTOM
	:-
	:func F_SortAscen(a, b):
	:·tif a[0] < b[0]:return true
	:·treturn false;
	:var MyArray = [[5, "Potato"], [9, "Rice"], [4, "Tomato"]];
	:MyArray .sort_custom(F_SortAscen);
	:print(MyArray) # Prints [[4, Tomato], [5, Potato], [9, Rice]].
	:# Descending, lambda version.
	:MyArray .sort_custom( func (a, b): return (a[0] > b[0]) );
	:print(MyArray ) # Prints [[9, Rice], [5, Potato], [4, Tomato]].
	:-
	:.REDUCE
	:-
	:Realiza una operacion sobre los miembros del array y retorna un
	:array con el resultado.
	:-
	:print( [1, 2, 3].reduce(F_Sum, 10)) # Prints 10+1+2+3 =16.
	:print( [1, 2, 3].reduce( func (accum, number): return (accum + number), 10))
	:func F_Sum(accum, number):·treturn accum + number;
	:-
	:.MAP
	:-
	:Realiza una operacion en cada uno de los elementos del array.
	:-
	:print([1, 2, 3].map(F_Neg)) # Prints [-1, -2, -3].
	:print([1, 2, 3].map(func (number): return -number) ) # Prints [-1, -2, -3].
	:func F_Neg(number):return -number;
*CLASE - OS
	:Da acceso a datos del systema operativo.
	:-
	:- - - PROPIEDADES
	:bool·t·tdelta_smoothing [default: true]
	:bool·t·tlow_processor_usage_mode [default: false]
	:int·t·tlow_processor_usage_mode_sleep_usec [default: 6900]
	:- - - METODOS
	:void·t·talert(text: String, title: String = "Alert!")
	:void·t·tclose_midi_inputs()
	:void·t·tcrash(message: String)
	:int·t·tcreate_instance(arguments: PackedStringArray)
	:int·t·tcreate_process(path: String, arguments: PackedStringArray, open_console: bool = false)
	:void·t·tdelay_msec(msec: int) const
	:void·t·tdelay_usec(usec: int) const
	:int·t·texecute(path: String, arguments: PackedStringArray, output: Array = [], read_stderr: bool = false, open_console: bool = false)Keyfind_keycode_from_string(string: String)const
	:String·t·tget_cache_dir() const
	:PackedString·tArrayget_cmdline_args()
	:PackedString·tArrayget_cmdline_user_args()Stringget_config_dir() const
	:PackedString·tArrayget_connected_midi_inputs()Stringget_data_dir() const
	:String·t·tget_distribution_name() const
	:String·t·tget_environment(variable: String) const
	:String·t·tget_executable_path() const (Con el Exe.)
	:PackedString·tArrayget_granted_permissions() const
	:String·t·tget_keycode_string(code: Key) const (Codigo Ascii de una tecla)
	:String·t·tget_locale() const
	:String·t·tget_locale_language() const
	:int·t·tget_main_thread_id() const
	:Dictionary·tget_memory_info() const
	:String·t·tget_model_name() const
	:String·t·tget_name() constintget_process_id() const
	:int·t·tget_processor_count() const
	:String·t·tget_processor_name() const
	:PackedStringArray·tget_restart_on_exit_arguments() const
	:int·t·tget_static_memory_peak_usage() const
	:int·t·tget_static_memory_usage() const
	:String·t·tget_system_dir(dir: SystemDir, shared_storage: bool = true) const
	:String·t·tget_system_font_path(font_name: String, weight: int = 400, stretch: int = 100, italic: bool = false) const
	:PackedStringArray·tget_system_font_path_for_text(font_name: String, text: String, locale: String = "", script: String = "", weight: int = 400, stretch: int = 100, italic: bool = false) const
	:PackedStringArray·tget_system_fonts() const
	:int·t·tget_thread_caller_id() const
	:String·t·tget_unique_id() const
	:String·t·tget_user_data_dir() const
	:String·t·tget_version() const
	:PackedStringArray·tget_video_adapter_driver_info() const
	:bool·t·thas_environment(variable: String) const
	:bool·t·thas_feature(tag_name: String) const
	:bool·t·tis_debug_build() const
	:bool·t·tis_keycode_unicode(code: int) const
	:bool·t·tis_process_running(pid: int) const
	:bool·t·tis_restart_on_exit_set() const
	:bool·t·tis_sandboxed() const
	:bool·t·tis_stdout_verbose() const
	:bool·t·tis_userfs_persistent() const
	:Error·t·tkill(pid: int)
	:Error·t·tmove_to_trash(path: String) const
	:void·t·topen_midi_inputs()
	:String·t·tread_string_from_stdin()
	:bool·t·trequest_permission(name: String)
	:bool·t·trequest_permissions()
	:void·t·trevoke_granted_permissions()
	:void·t·tset_environment(variable: String, value: String) const
	:void·t·tset_restart_on_exit(restart: bool, arguments: PackedStringArray = PackedStringArray())
	:Error·t·tset_thread_name(name: String)
	:void·t·tset_use_file_access_save_and_swap(enabled: bool)
	:Error·t·tshell_open(uri: String)
	:Error·t·tshell_show_in_file_manager(file_or_dir_path: String, open_folder: bool = true)
	:void·t·tunset_environment(variable: String) const
	:- - - ENUMERADORES
	:enum  RenderingDriver:
	:·t RENDERING_DRIVER_VULKAN = 0 (The Vulkan)
	:·tRENDERING_DRIVER_OPENGL3 = 1(The OpenGL 3)
	:enum  SystemDir:
	:·tSYSTEM_DIR_DESKTOP = 0 (Desktop directory path.)
	:·tSYSTEM_DIR_DCIM = 1 (DCIM (Digital Camera Images) directory path.)
	:·tSYSTEM_DIR_DOCUMENTS = 2 (Documents directory path.)
	:·tSYSTEM_DIR_DOWNLOADS = 3 (Downloads directory path.)
	:·tSYSTEM_DIR_MOVIES = 4 (Movies directory path.)
	:·tSYSTEM_DIR_MUSIC = 5 (Music directory path.)
	:·tSYSTEM_DIR_PICTURES = 6 (Pictures directory path.)
	:·tSYSTEM_DIR_RINGTONES = 7 (Ringtones directory path.)
*CLASES
	:-Podemos definir que un script sea una CLASE
	:Usaremos la sentencia.
	:class_name NombreClase
	:-De este modo le decimos que todo el script se considera
	:una clase con sus funciones y variables.
	:Pero no es necesario, tambien podemos
	:en un solo script crear distintas clases usando "class"
	:-Tambien podemos definir si esta clase HEREDA de otra clase
	:con el comando "extends"
	:Es el equivalente en C# a Public Class MyClase:ClasePadre
	:-Para definir dentro de la clase variables o funciones
	:privadas usaremos el "_" delante de la variable.
	:Pero es solo una convicion ya que no es privada real mente
	:pero indica al programador que son de uso interno.
	:Para instanciar una clase a una variable se usa el comando "new"
	:var NombreVar=cls_file.new(Para1,Para2,ParaX);
	:# Script con multiples clases.
	:exteds CharacterBody2D
	:class NombreClase:
	:·t# Esto es una variable privada
	:·tvar _VAR1:int=2;
	:·tfunc _init(Parametros):
	:·t·tpass
	:·t#END _Init
	:·t #esto es una funcion privada.
	:·tfunc _FncPrivada ():
	:·t·tpass;
	:·t#END _FncPrivada
	:#END Clase
	:# Todo el script es una clase.
	:exteds CharacterBody2D
	:class_Name NombreClase;
	:# Esto es una variable privada
	:var _VAR1:int=2;
	:func _init(Parametros):
	:·tpass
	:#END _Init
	:#esto es una funcion privada.
	:func _FncPrivada ():
	:·tpass;
	:#END _FncPrivada
	:- -
	:ENCAPSULACION
	:- -
	:Podemos encapsular variables en una clase usando la el comando
	:PROPERTY y asociando el get y el set a funciones especificas.
	:- -
	:# Para la version del godo 4.2
	:var _BasID:String;
	:@export var V_BasID: String="":
	:·tget:return _BasID;
	:·tset(value):_BasID = value;
	:- -
	:# Para otra version
	:@export var m_vecSize:Vector3 = Vector3(1,1,1) : set = setSize, get = getSize
	:func getSize():
	:·treturn m_vecSize
	:func setSize(a):
	:·tm_vecSize = a
*COMENTARIOS
	:Son textos que no se ejecutan y nos permiten añadir
	:descripciones al codigo o comentarios.
	:-
	:Existen dos modos de hacer comentarios.
	:De una sola linea o Multilinea.
	:-
	:#Comentario de una linea.
	:-
	:'''
	:Comentario
	:multilinea
	:'''
	:-
	:En GDScript tenemos dos modos de comentarios.
	:-
	:De una sola linea.
	:-_ #Esto es un comentario.
	:Todo lo que este a la derecha del # es un comentario.
	:Tambien se pueden poner al final de una cadena de
	:instruciones.
	:_ print("Hola mundo");#Comentario
	:-
	:De mas de una linea.
	:En este caso se usan 3 comillas simples para abrir
	:y otras 3 comillas simples para cerrar el comentario
	:_ '''
	:_ Esto es un comentario
	:_ multilinea
	:_ '''
*CONDICIONALES IF y MACTH
	:Son sentencias de control de flujo que solo ejecutan
	:su bloque de comandos si la o las condiciones son correctas.
	:-Operadores logicos.
	:Son los simbolos encargados de indicar que tipo de
	:comparacion realizar.
	:== = Igual que.
	:=== = Exactamente igual que.
	:!= = Distinto que.
	:> = Mayor que
	:< = Menor que
	:>= = Mayor o igual que
	:<= = Menor o igual que.
	:and o && = todas sentencias son verdaderas (A y B)
	:or o || = Alguna de las sentencias es verdadera (A o B)
	:not o ! = La sentencia no es verdadera ( A no es verdadera)
	:NT ! o not tambien se pueden usar para complementar
	:una variable (if (A && !B): )=( Si A es verdad y B NO es verdad)
	:-
	:- IF (Comparacion) : Comandos.
	:-
	:Las condiciones pueden o no estar entre ().
	:El inicio del codigo se define con :
	:El codigo tiene que estar tabulado por encima del nivel del if.
	:func F_Print(M_DELTA):
	:·tvar M_Q:int=2;
	:·t·tif (M_DELTA > 1 && M_Q==2):
	:·t·t·tprint ("Delta > 1",M_DELTA);
	:·t·telif (M_DELTA < 1 && M_Q==2):
	:·t·t·tprint ("Delta < 1",M_DELTA);
	:·t·telse:
	:·t·t·tprint ("Delta = 1",M_DELTA);
	:·t·t#endif
	:#Fin Funcion F_Print
	:-
	:MATCH VARIABLE: CASO1: CASO2: CASOX: _:
	:-
	:Funciona con un IF elIF donde se evalua el valor de la VARIABLE.
	:en este caso el _: funciona como el ELSE:
	:-
	:match (M_DELTA):
	:·t(1):
	:·t·tprint("Delta =1");
	:·t(2): print("Delta =2");
	:·t_: #Case Else
	:·t·tprint("Delta ni 1 ni 2");
	:#Fin del MATCH
*CONFIGURAR ENTORNO
	ª10089ª10088
	:Un punto principal a la hora de crear un videojuego es la
	:configuracion del entorno.
	:-
	:Es necesario poder definir parametros como:
	:La resolucion, La caliad de sombra, La calidad de los efectos,
	:La iluminacion etc
	:-
	:Muchos de estos parametros se configuran modificando
	:directamente los parametros del motor.
	:Otras se tienen que configurar directamente sobre los objetos.
	:-
	:Para configura el motor se usara el nodo
	:"ProjectSettings.set_setting(KEY,VAL)"
	:Estas claves se pueden obtener por medio de la pantalla de
	:"Project/Project Setings".
	:Si en el titulo de la propiedad pulsamos BtDer nos dara las
	:opciones de copiar la KEY que se usa para configurar
	:ese parametro.
	:-
	:func F_Settings_Set():
	:_ var M_CfgKey="";
	:_ #-----------------
	:_ if(settings.has("aniso")==null):settings["aniso"]=0;
	:_ M_CfgKey="rendering/textures/default_filters/anisotropic_filtering_level";
	:_ F_Tron("F_Settings_Set(aniso)="+str(settings["aniso"]));
	:_ #-----------------
	:_ #Se ha mantenido disabled, Shadows acepta de 0 a 6,
	:_ # En el settings = disable,0,1,2,3 etc
	:_ # Si setting=Disable cfg=0 y si setting=0 tambien cfg=0
	:_ if(settings.has("shadows")==null):
	:_ _ settings["shadows"]="disabled";
	:_ M_CfgKey="rendering/lights_and_shadows/positional_shadow/soft_shadow_filter_quality";
	:_ ProjectSettings.set_setting(M_CfgKey,0);
	:_ if(settings["shadows"]!="disabled"):
	:_ _ ProjectSettings.set_setting(M_CfgKey,int(settings["shadows"]));
	:_ F_Tron("F_Settings_Set(shadows)="+str(settings["shadows"]));
	:_ #-----------------
	:_ if(settings.has("gi")==null):settings["gi"]="disabled";
	:_ M_CfgKey="rendering/global_illumination/voxel_gi/quality";
	:_ #Nt: el disabled desactiva directamente las luces
	:_ #NT: El motro solo pilla dos valores 0=low y 1 high
	:_ if(globals.settings["gi"]=="normal"):
	:_ _ ProjectSettings.set_setting(M_CfgKey,0);
	:_ if(globals.settings["gi"]=="high"):
	:_ _ ProjectSettings.set_setting(M_CfgKey,1);
	:_ F_Tron("F_Settings_Set(gi)="+str(settings["gi"]));
	:_ #-----------------
	:_ if(settings.has("text_lang")==null):settings["text_lang"]="en";
	:_ TranslationServer.set_locale(settings["text_lang"]);
	:_ F_Tron("F_Settings_Set(text_lang)="+str(settings["text_lang"]));
	:_ #-----------------
	:_ if(settings.has("msaa")==null):settings["msaa"]=0;
	:_ M_CfgKey="rendering/anti_aliasing/quality/msaa_2d";
	:_ ProjectSettings.set_setting(M_CfgKey,settings["msaa"]);
	:_ F_Tron("F_Settings_Set(msaa)="+str(settings["msaa"]));
	:_ #-----------------
	:_ if(settings.has("msaa_3d")==null):settings["msaa_3d"]=0;
	:_ M_CfgKey="rendering/anti_aliasing/quality/msaa_3d";
	:_ ProjectSettings.set_setting(M_CfgKey,settings["msaa_3d"]);
	:_ F_Tron("F_Settings_Set(msaa_3d)="+str(settings["msaa_3d"]));
	:_ #-----------------
	:#END F_Settings_Set
*EJ - Botones Dinamicos y Eventos Dinamicos
	:En este ejemplo creo 4 botones dinamicos y
	:enlazo su evento Button_up a una funcion pasandole
	:un valor.
	:-
	:Callable(Control,NomFuncion)
	:Crea un objeto que indica una funcion en cualquier
	:Control.Script y el el nombre de esa funcion.
	:-
	:Connect(NomEvento,Callable)
	:Conecta un evento con un callable.
	:Dice la funcion y donde esta el manejador
	:de ese evento.
	:-
	:Otro modo mas simple y que permite mandar variables
	:seria:
	:NomControl.NomEvent.connect(NomFuncion.bind(Valor));
	:No tiene mucho sentido bind = conectar pero...
	:Conecta el NomEvent del NomControl con NomFuncion
	:y le manda Valor como parametro.
	:-
	:func _ready():
	:·tvar Mq:int=0;
	:·twhile(Mq<4):
	:·t·tvar MBt=Button.new();
	:·t·tMBt.name="BT_ResX"+str(Mq);
	:·t·tMBt.set_size(Vector2(50,30));
	:·t·tMBt.text=str(((Mq*200)+600));
	:·t·tself.add_child(MBt);
	:·t·tMBt.set_position(Vector2((100+(Mq*50)),0));
	:·t·tvar MCall=Callable(self,"F_Evt_MyButton_Up");
	:·t·t#MBt.connect("button_up",MCall);
	:·t·tMBt.button_down.connect(F_Evt_MyButton_Up.bind(MBt));
	:·t·tV_ResX.append(MBt);#Añado Boton a mi tabla.
	:·t·tMq+=1;
	:·t#End While Mq
	:·tprint("Botones:"+str(V_ResX.size()));
	:·tpass # Replace with function body.
	:#End Func _ready
	:func F_Evt_MyButton_Up(VAL):
	:·tif (VAL is Button):
	:·t·tprint("MyBtPress"+str(VAL.name));
	:·telse:
	:·t·tprint("MyBtPress"+str(VAL));
	:#End Func F_Evt_MyButton_Up
*EJ - Crear Tabla de controles dinamicos
	:Tras PreCargar la escena madre y
	:obtener el control de esa escena.
	:Rellenamos una tabla con colnes de ese boton
	:y los añadimos a la escena actual.
	:-EJ:
	:F_Tron("PRE-LOAD");
	:_ var M_SCN_REPO=preload("res://SCN_REPO/SCN_REPO.tscn").instantiate();
	:_ F_Tron("PRE-LOAD.. OK");
	:_
	:_ F_Tron("CLON BUTTON");
	:_ var M_BtClon=M_SCN_REPO.get_node("REPO_BTBase");
	:_ F_Tron("CLON BUTTON.. OK");
	:_
	:_ F_Tron("Botones ADD2TABLE");
	:_ V_TBt.clear();
	:_ var M_q:int=0;
	:_ var M_Pos:Vector2;
	:_ var M_Size:Vector2;
	:_ while (M_q<20):
	:_ _ var M_Bt:Button=M_BtClon.duplicate();# Button.new();
	:_ _ M_Bt.name="BT"+str(M_q);
	:_ _ M_Bt.text=M_Bt.name;
	:_ _ V_TBt.append(M_Bt);
	:_ _ M_q+=1;
	:_ #EndWhile
	:_ F_Tron("Botones ADD2TABLE.. OK");
	:_
	:_ F_Tron("Botones CFG + ADD");
	:_ M_q=0;M_Size.x=40;M_Size.y=20;
	:_ while (M_q<20):
	:_ _ var M_Bt:Button=V_TBt[M_q];
	:_ _ self.add_child(M_Bt);
	:_ _ M_Bt.set_size(M_Size,false);
	:_ _ M_Bt.visible=true;
	:_ _ M_Pos.x=M_q*50;
	:_ _ M_Bt.set_position(M_Pos);
	:_ _ M_q+=1;
	:_ #EndWhile
	:_ F_Tron("Botones CFG + ADD.. OK");
	:#End Func _ready
*EJ - Crear un Boton dinamico con evento
	:Con este codigo ejecutado en el nodo padre creamos
	:un nodo button y le añadimos un evento al terminar el
	:_ready();
	:-
	:extends Node
	:func _ready():
	:_ # Crear el botón
	:_ var boton = Button.new()
	:_ boton.text = "Mostrar Alerta"
	:_ boton.rect_min_size = Vector2(200, 50)
	:_ add_child(boton)
	:_ # Conectar la señal "pressed" del botón a la función mostrar_alerta
	:_ boton.connect("pressed", self, "mostrar_alerta")
	:_
	:func mostrar_alerta():
	:_ # Crear la alerta (un cuadro de diálogo)
	:_ var alerta = AcceptDialog.new()
	:_ alerta.dialog_text = "¡Esto es una alerta personalizada!"
	:_ alerta.add_button("Aceptar", true) # Botón para cerrar la alerta
	:-
	:_ # Agregar la alerta como un hijo del nodo principal
	:_ add_child(alerta)
	:_ alerta.popup_centered() # Mostrar la alerta en el centro de la pantalla
*EJ - Enlazar con Blender
	:El godot se puede enlazar con proyectos del Blender.
	:Para ello tenemos que indicarle dos cosas.
	:1- Indicarle donde tenemos instalado el blender.
	:2- Decirle que use la importacion del Blender.
	:-
	:1- En Editor/Editor Settings
	:- Buscamos Blender
	:- En FileSystem/Import definimos la ruta donde
	:- tenemos instalado el Blender.
	:-
	:2 - En Project/ProjectSeting
	:- Activamos la Ver paramateros avanzados (Advanced)
	:- Buscamos "Blender"
	:- En FileSystem/Import lo ponemos como Enabled.
	:-
	:- Ahora Creamos una carpeta en el proyecto para
	:- nuestros Blenders en el GODOT.
	:- Guardamos nuestro Blend en esa carpeta.
	:- Ahora nos permite añadir los objetos del Blend
	:- al proyecto.
	:-
*EJ - Importar objetos de Blender
	:Teniendo el Blender el modelo con todos los objetos asociados
	:a la armadura y las animaciones .
	:Lo selecionamos todo .
	:Exportamos a GLTF2.
	:En las ultimas versiones de blender vienen como addons por
	:lo que para exportar se tiene que añadir el addon GLTF2.
	:Al exportar en blender selecionamos.
	:-Selected Objects
	:-+Y Up
	:-Apply Modifiers.
	:-UVs
	:-Normals
	:-VertexColors.
	:-Material = Exports.
	:-Images = Atumatic.
	:-
	:Guardamos el fichero en la carpeta configurada en el GODOT
	:para las importaciones.
	:-
	:Ahora en GODOT
	:-
	:Creamos una nueva scena.
	:Añadimos una Camera
	:Tenemos que tener configurado una carpeta para los
	:resources de blender donde pusimos el GLB
	:Al abrir el GLB importado nos dira si que remos una escena heredada
	:le decimos que si y la guardamos.
	:La estrucutra sera.
	:ESCENA
	:_ _ AnimationPlayer
	:_ _ Armature : Node3D
	:_ _ _ Skeleton3D : Skeleton3D
	:_ _ _ _ Mesh1 :MeshInstance3D
	:_ _ _ _ MeshX :MeshInstance3D
*EJ - Instanciar Controles predefinidos
	:Podemos crear controles predefinidos y preconfigurados.
	:Para ello tenemos que añadirlos a una nueva escena.
	:Los creamos y los configuramos.
	:PreCargamos la escena.
	:Buscamos el control en esa escena .
	:Reasignamos el padre a donde queramos.
	:EJ:
	:func _ready():
	:_ F_Tron("_ready");
	:_ #Modifico el texto de un label creado
	:_ var MLb:Label=$Lb_BtPulsado;
	:_ MLb.text="Hola";
	:_
	:_ #- Precarga de forma rapida una escena.
	:_ F_Tron("PRE-LOAD");
	:_ var M_SCN_REPO=preload("res://SCN_REPO/SCN_REPO.tscn").instantiate();
	:_ F_Tron("PRE-LOAD.. OK");
	:_
	:_ #- Carga todo lo necesario de la escena.
	:_ #var M_SCN_REPO=load("res://SCN_REPO/SCN_REPO.tscn");
	:_ #print("LOAD");
	:_
	:_ #-- Añadimos la escena instanciada a la escena actual.
	:_ #get_tree().root.add_child(M_SCN_REPO)
	:_ #F_Tron("ADDChild");
	:_ #self.add_child(M_SCN_REPO);
	:_ #F_Tron("ADDChild.. OK");
	:_
	:_ F_Tron("CLON BUTTON");
	:_ var M_BtClon=M_SCN_REPO.get_node("REPO_BTBase");
	:_ F_Tron("CLON BUTTON.. OK");
	:_
	:_ F_Tron("CLON BUTTON Instance");
	:_ M_BtClon.reparent(self);
	:_ #self.add_child(M_BtClon);
	:_ F_Tron("CLON BUTTON Instance .. OK");
	:_
*EJ - Libreria de Animaciones
	ª10154ª10153ª10152ª10151ª10150ª10149ª10148ª10147ª10146ª10145ª10144ª10143ª10142ª10141ª10140ª10139ª10138ª10137ª10155ª10156ª10157ª10158
	:https://www.youtube.com/watch?v=xGHgA5oftxY
	:- -
	:Nos descargamos el zip del video y lo instalamos en el blender en
	:la seccion addons.
	:En un proyecto del blender nuevo borramos todo.
	:En el addom que aparece en la barra derecha pinchamos en
	:"insert root", y en "animation files/soure" selecionamos la carpeta
	:con las animaciones.
	:Presionamos en "Inport Animations" del addon y nos traera todos los
	:FBX de la carpeta.
	:(Podemos aplicar el filtro de nombres de mas a bajo)
	:Borramos en el OUTLINER del blender todas las ARMATURES  menos
	:la primera que ya tienen todas las ANIMACIONES
	:Entramos en la pestaña de "ANIMACIOENS"
	:Modificamos el panel inferior a "Dope Shet" y le decimos que edite
	:el "Action Editor"
	:Ahora cuando ya estan todas bien (Aplicando o no el filtro de renombre)
	:Exportamos la armadura a formato ".glb"
	:Ahora en GODOT colocamos los .GLB a una carpeta y en la pestaña
	:superior en IMPORT selecionamos que queremos importar una
	:ANIMATION LIBRERY y le damos a REIMPORT
	:Es posible que pida o tengamos que guardar y reiniciar GODOT
	:segun la version.
	:- -
	:Reentramos al GODOT y pikamos dos veces sobre el fichero importado.
	:Nos mostrara la lista de animacions pero tendremos que decirle
	:el tipo de esqueleto ya que no lo importa.
	:Selecionamos el ESQUELETO y en la derecha creamos un nuevo
	:BONEMAP de tipo "SkeletoProfileHunamoid" y REIMPORTAMOS
	:- -
	:Tenemos que tener tambien en GLB las armaduras con los huesos y demas
	:pero sin animaciones .
	:NT: Para exportarla tenemos que selecionar todo incluso lo de dentro del la
	:armadura, si no solo exportara la estructura.
	:Ahora en GODOT para el KEKO le pikamos dos veces y le decimos al igual
	:que el tipo de esqueleto es humanoide y REIMPORTAMOS
	:Luego tenemos que decirle que cree una escena basada en ese KEKO
	:por medio del menu en el GLB del KEKO "New Inherited Escene"
	:- -
	:Por ultimo al crear el objeto ESCENA para el KEKO añade una control
	:ANIMATION PLAYER , si no ha cogido por defecto la biblioteca de
	:animaciones tendremos que cerar una y asociarla a la ANIMACIONES que
	:hemos creado antes .
	:- -
	:NT: El renombrar huesos y animaciones del final
	:Mejor hacerlo cuando tengas ya todas las animaciones
	:luego da problemas.
	:- -
	:Godot tiene la posibilidad de crear una libreria de
	:animaciones para , si nuestras armaduras tiene
	:los nombres de los huesos y los grupos de
	:vertices iguales , se puedan asignar facilmente.
	:- -
	:Para ello lo primero es depurarlas en blender.
	:Podemos obtenerlas desde la web de mixamo.
	:Pero siempre que los nombres de los huesos sean
	:iguales podemos tomar un esqueleto y animarlo
	:nosotros mismos.
	:- -
	:Obtenemos desde mixamo las animaciones en .fbx,
	:Las importamos a blender y las depuramos y renombramos.
	:- -
	:Por defecto creara un esqueleto con cada animacion.
	:Podemos selecionar nuestro esqueleto y en el
	:"NoLinealAnimation" asignarla a nuestro esqueleto de
	:ese modo podremos borrar el esqueleto importado y
	:la animacion no se perdera.
	:- -
	:Cuando la importemos recomiendo poner al final
	:del nombre de la animacion la biblioteca de donde
	:salio ya que podemos tener distintos Run o Walking.
	:- -
	:Ahora que ya tenemos un monton de esqueletos cada
	:uno con una animacion .
	:Selecionamos NUESTRO esqueleto y le asignamos
	:cada animacion de cada esqueleto importado.
	:Para lo cual,
	:Selecionamos nuestro esqueleto.
	:En la ventana de "Action Editor" buscamos la animacion.
	:NT: Si pusimos la libreria podemos filtrar.
	:y pulsamos en el boton "PushDown" de ese modo
	:Aladira a la lista de animaciones de nuestro esqueleto
	:esa animacion.
	:- -
	:Ahora que ya tenemos todas las animaciones asociadas
	:a nuestro esqueleto podemos eliminar las armaduras
	:importadas.
	:- -
	:Ten en cuenta que los nombres de los
	:huesos de la animacion modificados tienen que
	:corresponder con Huesos y Grupos de vertices.
	:- -
	:Para correjir si no te gustan los nombres puedes
	:usar este script en blender.
	:- -
	:import bpy
	:#__ FNC_FiltraTexto
	:def F_FiltraTexto(M_texto):
	:·tM_Res=M_texto;
	:·tM_Res=M_Res.replace("mixamorig:", "");
	:·tif ("mixamorig:" in M_Res):
	:·t·tM_Res=M_Res.replace("mixamorig:", "");
	:·tif ("Left" in M_Res):
	:·t·tM_Res=M_Res.replace("Left", "L_");
	:·tif ("Right" in M_Res):
	:·t·tM_Res=M_Res.replace("Right", "R_");
	:·treturn M_Res;
	:#__ FNC_FiltraTexto FIN
	:def F_Bones_Rename(V_ArmatureName):
	:·t# Obtenemos el objeto del esqueleto
	:·tM_Armature = bpy.data.objects.get(V_ArmatureName)
	:·tif (M_Armature is None or M_Armature.type != 'ARMATURE'):
	:·t·tprint("No se encontró el objeto de esqueleto o el objeto no es un esqueleto.")
	:·t·treturn
	:·t# Renombramos los huesos en todas las acciones
	:·tfor M_Action in bpy.data.actions:
	:·t·tfor fcurve in M_Action.fcurves:
	:·t·t·tM_data_path = fcurve.data_path;
	:·t·t·tM_data_path = F_FiltraTexto(M_data_path);
	:·t# Renombramos los huesos
	:·tfor M_Bone in M_Armature.data.bones:
	:·t·tM_Bone.name = F_FiltraTexto(M_Bone.name);
	:·t# Renombramos los grupos de vértices de la malla asociada al esqueleto
	:·tM_Malla_asociada = bpy.data.meshes.get(V_ArmatureName)  # Reemplaza esto con el nombre de tu malla asociada
	:·tif M_Malla_asociada:
	:·t·tfor V_Group in M_Malla_asociada.vertex_groups:
	:·t·t·tV_Group.name= F_FiltraTexto(V_Group.name);
	:# - - EJECUTAMOS
	:if __name__ == "__main__":
	:·tF_Bones_Rename("ArmatureBaseFemaleT")
	:- - -
*EJ - Movimiento Personalizado
	:Para caputrar el movimiento es tan simple como:
	:En el SCRIPT GLOBAL añadimos una funcion para obtener
	:que tecla se ha pulsado y extraer la direcion.
	:Esta direcion en 2 ejes la guardamos en una
	:varible golbal tipo Vector2.
	:#Movimiento personalizado
	:var V_Axis:Vector2;
	:func F_GetAxis()->Vector2:
	:·tV_Axis.x=int(Input.is_action_pressed("ui_right"))-int(Input.is_action_pressed("ui_left"));
	:·tV_Axis.y=int(Input.is_action_pressed("ui_down"))-int(Input.is_action_pressed("ui_up"));
	:·t#print(str(V_Axis.x)+" x "+str(V_Axis.y)+" y");
	:·treturn V_Axis.normalized();
	:#Fin Fnc F_GetAxis
	:En el juego, en el SCRIPT del CHARACTER ya sea
	:3D 2D o 2.5D añadimos una funcion que usando
	:esta variable aplique el desplazamiento.
	:OJO: no incorpora ni gravedad ni salto.
	:-
	:Copiamos la que viene por defecto a otra funcion.
	:-
	:#Esto viene de fabrica.
	:const SPEED = 300.0
	:const JUMP_VELOCITY = -400.0
	:# Get the gravity from the project settings to be synced with RigidBody nodes.
	:var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")
	:-
	:#Codigo por defecto en una funcion.
	:func F_MotionDefault(delta)->void:
	:·t#Add the gravity.
	:·tif not is_on_floor():
	:·t·tvelocity.y += gravity * delta
	:·t# Handle Jump.
	:·tif Input.is_action_just_pressed("ui_accept") and is_on_floor():
	:·t·tvelocity.y = JUMP_VELOCITY
	:·t# Get the input direction and handle the movement/deceleration.
	:·t# As good practice, you should replace UI actions with custom gameplay actions.
	:·tvar direction = Input.get_axis("ui_left", "ui_right")
	:·tif direction:
	:·t·tvelocity.x = direction * SPEED
	:·telse:
	:·t·tvelocity.x = move_toward(velocity.x, 0, SPEED)
	:·tmove_and_slide()
	:#End Func F_MotionDefault
	:#Mi funcion de desplazamiento.
	:func F_MotionControl(delta)->void:
	:·tvelocity.x=V.F_GetAxis().x*SPEED;
	:·tvelocity.y=V.F_GetAxis().y*SPEED;
	:·tmove_and_slide();
	:#End Fnc F_MotionControl
	:#El evento quedaria asi.
	:func _physics_process(delta):
	:·tF_MotionControl(delta);
	:·t#F_MotionDefault(delta);
	:#End func _physics_process
*EJ - RPG Controler 3D (Camara)
	ª10102ª10103ª10106ª10105ª10104ª10109ª10110ª10108ª10107ª10111ª10112ª10113ª10114ª10115ª10116ª10117ª10118ª10119
	:Ahora configuraremos la camara.
	:Lo que queremos es que la linea entre la camara y el
	:PJ siempre este visible por lo que tendremos que ocultar
	:esa parte.
	:Lo lograremos usando dos camaras una con el fondo real
	:otra con el frontal
	:Luego las mezclamos pero a la camara frontal le decimos
	:que cierta zona no la dibuje o la dibuje a medias.
	:-
	:Creamos una nueva escena para el Camera_rig
	:Añadimos una camara y en Cull Mask le decimos
	:que no renderize ninguna capa.
	:Este control manejara las vistas de las camaras que
	:haran de capas, osea que es el mezclador.
	:-
	:Añadimos dentro de esta camara un "SubviewportContainer"
	:que contendra las camaras renderizadoras de las capas.
	:y lo ajustamos a pantalla completa.
	:Dentro añadimos un VIEWPORT y dentro una CAMARA
	:-
	:Les damos nombres claros y lo copiamos para tener
	:dos SubViewPorts uno para el frontal y otro para
	:el Back.
	:-
	:Creamos el Script de la escena.
	:-
	:Los BackGroundViewport entregan imagenes con la escala
	:incorrecta Para que se ajuste a la pantalla a tiempo real
	:le definimos el tamaño por codigo. (Para que sea dinamico.)
	:Añadimos un Script a la raiz "CAMERA_RIG"
	:Añadimos una funcion Resize "F_Resize"
	:Creamos acceso a los ViewPorts
	:(Con CTRL y desplazando nos crea los @onereasy xxxx)
	:le decimos a cada ViewPort que su size sea el del DisplayServer.
	:-
	:Ahora tenemos que copiar la posicion general del Camera_Rig
	:a las camaras ya que como el ViewPort no es un control 3D
	:el GODOT no copia a sus hijos la posicion del padre y
	:tenemos que hacerlo por codigo.
	:-
	:Primero añadimos un nodo 3D en mi player para obtener
	:la posicon donde estara la camara y lo colocamos.
	:-
	:Ahora creamos un script dentro de una carpeta GLOBLAS
	:que se ejecutara siempre.
	:Dentro añadiremos una variable Node para compartir al player.
	:-
	:En el script del PLAYER en el _ready asignamos la variable
	:de GLOBALS.V_Player.
	:o mejor asignamos directamente a GLOBALS.V_CamPoint_N3D
	:el node3D que sera el manejador de camara.
	:-
	:func _ready():
	:_ V.F_PlayerSet(self);
	:_ V.F_PlayerCamPointSet($CamPoint_N3D);
	:-
	:Ahora en el script de la camara igualamos el global_transform
	:de GLOBALS.V.F_PlayerCamPointSet a nuestras Cam3D.
	:-
	:func _process(delta):
	:_ V_BackG_Cam3d.global_transform=V.V_PlayerCamPoint.global_transform;
	:_ V_Front_Cam3d.global_transform=V.V_PlayerCamPoint.global_transform;
	:#END _Process
	:-
	:Ahora configuramos la primera camara para que solo renderize
	:lo que este en la capa 1 y la segunda camara solo la capa 2
	:ajustando el "Cull Mask"
	:-
	:En el mapa configuramos las paredes frontales en el
	:visualinstance3D.Layer =2 y las del fronto en el 1.
	:-
	:En la camara le decimos al subviewport que el backgrouns de
	:los objetos sean transparentes
	:OJO el orden de las camaras afecta. la ultima camara se
	:sobrepone a todo.
	:-
	:Podemos modificar el codigo para que muestre las vistas
	:de las camaras en porciones separadas.
	:-
	:En el Escenario principal le decimos que las luces las
	:trabaje tambien en las dos capas.
	:-
	:Tambien si queremos en el escenario principal le añadimos
	:un WorldEnviroment para efectos y demas.
	:-
	:OJO: Si añades un WorldEnviroment solo te funcionara en
	:Vulkan , en modo compatible no funciona y se carga el alpha de
	:las capas de la camara.
	:-
	:Por ultimo le añadimos a la escena de las camaras el sombreador
	:para que no nos dibuje el centro de la camara frontal.
	:Esto lo hacemos añadiendiendo en el ViewPortContainer un
	:material Shider en el CambasItem. para que aplique un
	:cirlculo alha a lo que renderiza la camra frontal.
	:-
	:Por ultimo añadiremos un script a los objetos del frente
	:para que modifiquen su capa si estan delante o detras del
	:muñeco y de esa manera poder tener paredes y objetos no
	:afectados por la transparencia.
	:Creamos dos funciones una que mande la pared al fondo y otra
	:que la mande al frente (Capa 1 o Capa 2)
	:Y en el process revisamos la posicon X del player con la posicion X
	:de la pared usando
	:if(V.V_Player.global_position.x>global_position.x):
	:para que si esta delante o detras llame a una u otra funcion.
	:NT:Tambien he añadido una funcion que revisa en cada funcion
	:si ya esta la capa bien y solo modificarta una vez.
	:-
*EJ - Test For While
	:"_ " = <TAB>
	:Este Test revisa el uso de memoria y la velocidad de
	:los bucles FOR y WHILE
	:-
	:Conclusion, Para Fores pequeños es mejor el for
	:pero al crecer el for aumenta el uso de memoria y de
	:ciclos siendo mas rapido y mejor el while.
	:- RESULTADOS
	:Repeticiones X 1000
	:REP1: 1000000 REP2: 1000000 REP3: 1000000
	:MEM0:49144563 MEM1:49207191 MEM2:49207191 MEM3:49207191
	:MEMT1:62628 MEMT2:0 MEMT3:0
	:TBas=815 TFor1=875 TWhile=938 TFor2=998
	:TFor1-TBas=60 TWhile-TFor1=63 TFor2-TWhile=60
	:----
	:Repeticiones X 10000
	:REP1: 100000000 REP2: 100000000 REP3: 100000000
	:MEM0:49144563 MEM1:49665943 MEM2:49665943 MEM3:49665943
	:MEMT1:521380 MEMT2:0 MEMT3:0
	:TBas=806 TFor1=6578 TWhile=12791 TFor2=18773
	:TFor1-TBas=5772 TWhile-TFor1=6213 TFor2-TWhile=5982
	:-----
	:Repeticiones X 15000
	:REP1: 225000000 REP2: 225000000 REP3: 225000000
	:MEM0:49144563 MEM1:50190231 MEM2:50190231 MEM3:50190231
	:MEMT1:1045668 MEMT2:0 MEMT3:0
	:TBas=913 TFor1=14364 TWhile=28680 TFor2=41975
	:TFor1-TBas=13451 TWhile-TFor1=14316 TFor2-TWhile=13295
	:-------
	:Repeticiones X 22000
	:REP1: 484000000 REP2: 484000000 REP3: 484000000
	:MEM0:49144563 MEM1:51238807 MEM2:51238807 MEM3:51238807
	:MEMT1:2094244 MEMT2:0 MEMT3:0
	:TBas=820 TFor1=31757 TWhile=62000 TFor2=94092
	:TFor1-TBas=30937 TWhile-TFor1=30243 TFor2-TWhile=32092
	:-------
	:Repeticiones X 30000
	:REP1: 900000000 REP2: 900000000 REP3: 900000000
	:MEM0:49144563 MEM1:51238807 MEM2:51238807 MEM3:51238807
	:MEMT1:2094244 MEMT2:0 MEMT3:0
	:TBas=918 TFor1=57982 TWhile=114198 TFor2=171330
	:TFor1-TBas=57064 TWhile-TFor1=56216 TFor2-TWhile=57132
	:------------
	:Repeticiones X 30000
	:REP1: 0 REP2: 900000000 REP3: 0
	:MEM0:49139803 MEM1:49139803 MEM2:49136887 MEM3:49136887
	:MEMT1:0 MEMT2:-2916 MEMT3:0
	:TBas=911 TFor1=911 TWhile=56806 TFor2=56806
	:TFor1-TBas=0 TWhile-TFor1=55895 TFor2-TWhile=0
	:-
	:-CODIGO
	:print("Hola Mundo");
	:var V_Rang:int=30000;
	:var V_Tim0_int:int=0;var V_Tim1_int:int=0;
	:var V_Tim2_int:int=0;var V_Tim3_int:int=0;
	:var Mq:int=0;var Mq1:int=0;
	:var V0:float =0;var V1:float =0;var V2:float =0;
	:var M0:float =0;var M1:float =0;var M2:float =0;var M3:float =0;
	:# - - Del For1
	:V_Tim0_int=Time.get_ticks_msec();
	:M0=Performance.get_monitor(Performance.MEMORY_STATIC);
	:# - - Del For1
	:V_Tim0_int=Time.get_ticks_msec();
	:M0=Performance.get_monitor(Performance.MEMORY_STATIC);
	:for MqX in range(V_Rang):
	:_ for MqY in range(V_Rang):
	:_ _ V0+=1;
	:_ #Fin For MqY
	:#Fin For MqX
	:#----- WHILES
	:V_Tim1_int=Time.get_ticks_msec();
	:M1=Performance.get_monitor(Performance.MEMORY_STATIC);
	:while (Mq<V_Rang):
	:_ Mq+=1;Mq1=0;
	:_ while (Mq1<V_Rang):
	:_ _ Mq1+=1;
	:_ _ V1+=1;
	:_ #Fin del While
	:#Fin del While
	:#----- FOR 2
	:V_Tim2_int=Time.get_ticks_msec();
	:M2=Performance.get_monitor(Performance.MEMORY_STATIC);
	:for MqR in range(V_Rang):
	:_ for MqT in range(V_Rang):
	:_ _ V2+=1;
	:_ #Fin For MqY
	:#Fin For MqX
	:V_Tim3_int=Time.get_ticks_msec();
	:M3=Performance.get_monitor(Performance.MEMORY_STATIC);
	:#--Resultados
	:print("Repeticiones X ",V_Rang);
	:print("REP1: ",V0," REP2: ",V1," REP3: ",V2);
	:print("MEM0:",M0," MEM1:",M1," MEM2:",M2," MEM3:",M3);
	:print("MEMT1:",(M1-M0)," MEMT2:",(M2-M1)," MEMT3:",(M3-M2));
	:print("TBas=",V_Tim0_int," TFor1=",V_Tim1_int," TWhile=",V_Tim2_int," TFor2=",V_Tim3_int);
	:print("TFor1-TBas=",(V_Tim1_int-V_Tim0_int)," TWhile-TFor1=",(V_Tim2_int-V_Tim1_int),
	:" TFor2-TWhile=",(V_Tim3_int-V_Tim2_int));
	:-
*ENUMS
	:Podemos obtener el tamaño o cantidad de items de un
	:enum con :
	:- -
	:eHabBasic.size()
	:- -
	:Podemos acceder tanto al valor como al texto por medio
	:del las funciones en el propio Enum.
	:- -
	:var M_Val = eHabBasic.values()[Pos];
	:var M_Key = eHabBasic.keys()[Pos];
	:- -
	:En su lugar podemos usar LISTAS.
	:enum ETipos{
	:·t_Teclado=0,
	:·t_MouseBt=1,
	:·t_MouseAxis=2,
	:·t_PadBt=3,
	:·t_PadAxis=4
	:}
	:@onready var Tipo:ETipos=ETipos._Teclado;
	:-
	:Por defecto Godot asigna a la KEY un numero comenzando
	:desde el 0
	:Pero tambien le podemos nosotros dar un numero o ID.
	:Para optener el id solo tenemos que llamar al enum.
	:-
	:var M_ID = ETipos._Teclado
	:-
	:Para tener el TEXTO de un enum usaremos
	:-
	:var M_TXT = ETipos.toString(ETipos._Teclado);
*ESCENAS Y NODOS
	:Godot se estructura con escenas y nodos
	:Una escena seria un objeto que tiene distintos nodos
	:Cada escena tiene un solo script.
	:-
	:Ejemplo.
	:Tenemos una "SILLA" que seria la escena.
	:Esta "SILLA" tiene 4 patas siendo cada pata un "NODO"
	:Para manejar la "SILLA" existe un SCRIPT-
	:-
	:Godot da colores a los nodos para ayudarnos.
	:[2D]
	:Los de 2D son AZULES.
	:El motro 2D es independiente no como suele pasar
	:en otros motores que usan una adaptacion del motor
	:3D para generar 2D.
	:Esto le permite mas rendimiento.
	:[3D]
	:Los de 3D son ROSAS.
	:[CONTROL]
	:Los de tipo control son de color VERDE
	:Se usan para entornos de usuario paneles y textos.
	:Un contador de puntos o de vida.
	:Se pueden usar tanto en 3D como en 2D
	:[GENERICOS]
	:Se pueden usar tanto en 3D como en 2D
*EVENTO - _input(event)
*FICHEROS
	:GODOT trabaja los ficheros como otros lenguajes.
	:1 - Se enlaza el fichero a una variable de un modo.
	:2 - Se realizan las operaciones sobre el fichero dado.
	:3 - Se Refresca el setado (propio al guardar.)
	:4 - Se Cierra el fichero
	:5 - Se desinstancia la variable (Para liberar la memoria.)
	:-
	:Para el enlace se usa el comando "FileAccess"
	:Despues le decimos el tipo de Acceso .
	:-
	:func save_config():
	:_ DirAccess.remove_absolute(save_path+"config.conf")
	:_ var f = FileAccess.open(save_path+"config.conf",FileAccess.WRITE)
	:_ f.store_var(settings)
	:_ f.flush();#Fuerza la escritura del los datos del buffer al archivo.
	:_ f.close();
	:_ f = null
	:_
	:func load_config():
	:_ var f= FileAccess.open(save_path+"config.conf", FileAccess.READ)
	:_ settings = f.get_var();
	:_ f.close();
	:_ f=null;
	:-
	:Estas son algunas de las propiedades que se pueden hacer sobre
	:los ficheros.
	:f.store_var(settings)
	:f.store_string("Texto");
	:f.file_exists("FILE");
	:f.get_error();
	:f.get_file_as_bytes("FILE");
	:f.get_file_as_string("FILE");
	:f.get_modified_time("FILE");
	:f.get_path();
	:f.get_path_absolute();
	:f.get_position();
	:f.get_real();
	:f.is_open();
	:f.open_compressed("FILE",FileAccess.READ,FileAccess.COMPRESSION_GZIP);
	:f.open_encrypted("FILE",FileAccess.READ,new key());
	:f.READ();
	:f.READ_WRITE();
	:f.WRITE();
	:f.WRITE_READ();
	:f.connect("SEÑAL",Callable(),flags);
	:f.disconnect("SEÑAL",Callable());
	:f.emit_signal("SEÑAL");
	:f.seek(20);
	:f.seek_end();
	:f.flush(); #Fuerza la escritura del los datos del buffer al archivo.
	:f.close();
	:- -
	:Tambien se puede guardar o cargar todo el texto
	:del fichero directamente.
	:Y podemos usar su libreria JSON para normalizar los
	:datos de la tabla a formato Texto.
	:- - -
	:# Guardo las tablas en el fichero Cifrando y JSONeando las tablas a texto
	:func F_SaveGame(M_FileName:String):
	:·t# Genero la tabla que unifica todos los datos
	:·tvar M_t:Array;
	:·tM_t.append(V_Ref_ClsGameCab.F_GetArray());
	:·tM_t.append(V_Ref_ClsKeys.F_GetArray());
	:·t# Borro el fichero si existe.
	:·tDirAccess.remove_absolute(M_FileName);
	:·tvar M_File =  FileAccess.open(M_FileName,FileAccess.WRITE);
	:·t# Paso la tabla a formato JSON
	:·tvar M_Str:String=JSON.stringify(M_t);
	:·t# Cifro la cadena JSoneada
	:·tM_Str=V_ClsCrypto.F_Cifra(M_Str);
	:·t# Guardo el fichero
	:·tM_File.store_string(M_Str);
	:·t# Guardo Buffer, Cierro y Libero
	:·tM_File.flush();
	:·tM_File.close();
	:·tM_File = null;
	:#END F_SaveGame
	:- - -
	:# Cargo un fichero y destripo con JSON las tablas de datos (Descifra)
	:func F_LoadGame(M_FileName:String):
	:·tif(FileAccess.file_exists(M_FileName)):
	:·t·tvar M_t:Array;
	:·t·tvar M_File =  FileAccess.open(M_FileName,FileAccess.READ);
	:·t·t# Cargo todo el texto del fichero
	:·t·tvar M_Str = M_File.get_as_text();
	:·t·t# Cierro y libero el fichero
	:·t·tM_File.close();
	:·t·tM_File=null;
	:·t·t# Descifro el texto cargado.
	:·t·tM_Str=V_ClsCrypto.F_DesCifra(M_Str);
	:·t·t# Reviso el texto y genero Genero la tabla usando JSON
	:·t·tM_t=JSON.parse_string(M_Str);
	:·t·t#- Separo la tabla en sus secciones.
	:·t·tif(M_t.size()==2):
	:·t·t·tV_Ref_ClsGameCab.F_SetArray(M_t[0]);
	:·t·t·tV_Ref_ClsKeys.F_SetArray(M_t[1]);
	:·t#END If FileExist
	:#END F_LoadGame
*FUNCION F_LOG()
	:Esta funcion creada para estar en el global
	:muestra un log en rama de las operaciones realizadas.
	:-
	:var M_LogRama:int=0;
	:# MAcc genera=1 , comenta=2 o sale=0 de una rama
	:func F_log(MScn:String,MTxt:String,MAcc:int=2):
	:·tvar M_Rama:String="|- |- |- |- |- |- |- |- |- |- |- |- |- |- |- ";
	:·tif(MAcc==1):M_LogRama=M_LogRama+1;
	:·tM_Rama=M_Rama.substr(0,(M_LogRama*3));
	:·tprint(
	:·t·t"["+
	:·t·tstr(Time.get_datetime_dict_from_system().hour) +":"+
	:·t·tstr(Time.get_datetime_dict_from_system().minute) +":"+
	:·t·tstr(Time.get_datetime_dict_from_system().second) +
	:·t·t"]:"+
	:·t·tM_Rama +
	:·t·t"("+MScn+")."+
	:·t·tMTxt
	:·t·t);
	:·tif(MAcc==0):M_LogRama=M_LogRama-1;
	:·tif(M_LogRama<0):M_LogRama=0;
	:#END F_Log
	:-
	:En cada ESCENA podemos crear estas funcioens
	:para hacer todo mas comodo.
	:-
	:extends Control
	:func F_LogAdd(MTxt:String,MVisible:bool=true):F_Log_(MTxt,MVisible,1);
	:func F_LogDel(MTxt:String,MVisible:bool=true):F_Log_(MTxt,MVisible,0);
	:func F_LogCom(MTxt:String,MVisible:bool=true):F_Log_(MTxt,MVisible,2);
	:func F_Log_(MTxt:String,MVisible:bool=true,MAcc:int=2):
	:·tif(MVisible):V.F_log("NOMBRE ESCENA",MTxt,MAcc);
	:-
	:En cada funcion o evento lo usaremos asi.
	:de ese modo una funcion revisada solo ponemos LogVis a false
	:y listo. o si
	:-
	:var M_LogVis:bool=false;
	:F_LogAdd("TEXTO CABECERA",M_LogVis);
	:F_LogCom("TEXTO COMENTARIO",M_LogVis);
	:F_LogDel("TEXTO CIERRE",M_LogVis);
	:-
	:La evolucion de esta funcion permite guardar en un fichero
	:el log mostrado o no mostrado.
	:PENDIENTE
	:-
*FUNCIONES y METODOS
	:Los METODOS y FUNCIONES son lo mismo.
	:La unica diferencia es el alcance.
	:Un metodo solo esta disponible dentro de una clase.
	:Una funcion esta disponible para todo el programa.
	:Los Metodos son funciones que pertenecen a una clase
	:y solo pueden ser llamados dentro de esa clase.
	:-
	:Las Funciones se pueden llamar desde cualquier
	:parte del prgrama.
	:-
	:Se usa la palabra func mas nombredefuncion entre
	:parentesis los parametros y con : indicamos que comienzan
	:las sentencias.
	:Recordemos que las sentencias dentro de bloques han de estar
	:tabuladas. (Aqui uso "_ " para indicar el tabulado)
	:-
	:-Esta funcion admite 3 parametros y devuelve 2 parametros.
	:func NombreFuncion(Par1,Par2,ParX):
	:_ Sentencia1
	:_ Sentencia2
	:_ SentenciaX
	:_ return DatoDevuelto,DatoDevuelto
	:_ #pass Esto permite definir dunciones sin contenido.
	:-
	:-Esta funcion admite 1 o 2 parametros , si no se pasa el
	:parametro 2 lo autogenera con valor 21 y devuelve 2 parametros.
	:func NomFunc(Par1,Par2=21):
	:_ Sentencia1
	:_ Sentencia2
	:_ SentenciaX
	:_ return DatoDevuelto,DatoDevuelto
	:-
	:-Esta funcion admite 1 parametro y le indicamos que
	:no devuelve nada o que devuelve bacio (void)
	:func NomFunc(Par1)->void:
	:_ Sentencia1
	:_ Sentencia2
	:_ SentenciaX
*GRILLMAP
	ª10080ª10079ª10061ª10082ª10081
	:Al igual que con el TILEMAP este nodo presenta una
	:cuadricula pero en 3D.
	:Este control como es logico funciona solo en nodos
	:o escenas NODE3D.
	:Este nodo para añadir objetos utiliza meshes agrupado
	:en librerias llamadas MESHLIBRARY.
	:Por defecto GODOT usa el formato de objetos GLB
	:que tambien es de codigo libre.
	:Para exportar a este formato segun la version del
	:BLENDER que uses puedes necesitar activar el
	:ADDON.
	:-
	:Comenzamos creando una ESCENA 3D.
	:Añadimos un GRIDMAP
	:Y al igual que con el TILEMAP aqui tambien necesitamos
	:añadir o definir una configuracion que sera la
	:libreria con los MESH (objetos) que usaremos.
	:En las opciones del GRIDMAP en MESHLIBRARY
	:pikamos y creamos una.
	:-
	:Cuando ya tenemos una MESHLIBRARY creada.
	:En nuestro GRIDMAP en su MES LIBRARY le damos
	:a LOAD y selecionamos la que hemos creado y
	:listo , ya nos aparece la lista de MESH que añadimos.
	:-
	:NOTA: un problema que tiene es que GRIDMAP no permite
	:modificaciones en la MESHLIBRARY si tenemos
	:que editar algun MESH perderemos todo lo hecho en
	:el GRIDMAP ya que se desinstancias las MESH.
	:-
	:En las propiedades del GRIDMAP podemos definir
	:el tamaño de la cuadricula y distintas propiedades.
	:Tambien podemos editar distintas alturas y rotar los
	:mesh con las opciones o teclas definidas para ello
	:que aparecen en el editor 3d el boton GRIDMAP
	*MESHLIBRARY
		ª10073ª10072ª10071ª10070ª10069ª10068ª10067ª10066ª10065ª10064ª10063ª10062ª10061ª10078ª10077ª10076ª10075ª10074
		:Para crear una MESHLIBRARY la creamos desde el
		:GRILLMAP.
		:Pero ahora tenemos que editarla para añadirle
		:MESHs.
		:Teniendo los objetos en un formato reconocido
		:por GODOT, por defecto .GLB.
		:Si en un fichero .GLB le pikamos nos habre otra
		:pantalla con el objeto y sus propeidades.
		:Revisamos que sean de tipo NODO3D y
		:REIMPORTAMOS para que lo normalize.
		:-
		:Ahora tenemos que crear una escena que contenga
		:los MESH.
		:Para ello lo mas facil es en los GLB
		:BotDer "Crear Escena Heredada"
		:Luego Elegimos uno y comiamos del resto
		:de las escenas el MESH a la escena elegida.
		:-
		:Podemos definir colisiones añadiendo a cada
		:MESH un STATICBODY3D y a este uno o mas
		:COLLISIONSHAPE3D.
		:-
		:Al selecionar un MESH nos mostrara un boton
		:Mesh en la pantalla 3D que nos dara distintas
		:opciones entre ellas para crear distintos mapas
		:de colisiones, Mapa de Navegacion, etc.
		:Lo mejor en muchos casos es crear tu un Mapa
		:simple o mas de uno para el mismo objeto.
		:-
		:Ahora solo nos queda EXPORTARLA como una
		:MESHLIBRARY.
		:Para ello selecionamos en el menu
		:Scene/Export As/MeshLibrary
		:Le decimos donde y listo.
*GSCRIPT BASICO
	ª10005ª10006ª10008ª10007ª10009
	:-Clases Metodos y funciones.
	:Todos los controles eredan del objeto node.
	:al crear un script nos genera por defecto dos
	:funciones
	:extends Node
	:-Este script hereda del objeto base "Node."
	:func _ready():
	:-Se ejecuta cuando se activa el nodo
	:func _process(delta)
	:-Se ejecuta cada vez que se dibuja la pantalla.
	:-El tiempo transcurrido entre refrescos es delta.
*INDICE (Aprendizaje)
	:Nivel Principiante
	:Instalación y Configuración:
	:Descargar e instalar Godot.
	:Explorar la interfaz de usuario.
	:Crear tu Primer Proyecto:
	:Crear un nuevo proyecto.
	:Familiarizarse con la estructura de carpetas del proyecto.
	:Introducción a las Escenas:
	:Aprender sobre las escenas en Godot.
	:Crear una escena básica.
	:Sprites y Texturas:
	:Importar y usar sprites y texturas.
	:Mover y rotar sprites.
	:Introducción a la Programación con GDScript:
	:Entender los conceptos básicos de GDScript.
	:Crear scripts simples para objetos.
	:Colisiones y Física:
	:Configurar colisiones entre objetos.
	:Aplicar física básica a objetos.
	:Nivel Intermedio:
	:Animaciones:
	:Crear animaciones simples para personajes u objetos.
	:Controlar animaciones mediante scripts.
	:Controles de Usuario:
	:Capturar la entrada del jugador (teclado, ratón, pantalla táctil).
	:Implementar controles de usuario personalizados.
	:Sistema de Partículas:
	:Crear efectos visuales con sistemas de partículas.
	:Sonido y Música:
	:Agregar efectos de sonido y música a tu juego.
	:Manejo de Escenas y Transiciones:
	:Cambiar entre escenas.
	:Crear transiciones suaves.
	:Nivel Avanzado:
	:Redes y Multijugador:
	:Implementar funciones multijugador en línea.
	:Sincronizar objetos y datos en red.
	:Optimización del Rendimiento:
	:Mejorar la eficiencia y el rendimiento de tu juego.
	:Publicación y Distribución:
	:Preparar tu juego para su lanzamiento en diferentes plataformas.
	:Distribuir tu juego en tiendas en línea.
	:Extensiones y Plugins:
	:Explorar extensiones y plugins para ampliar las capacidades de Godot.
	:Contribuir a la comunidad de Godot.
	:Resolución de Problemas y Depuración:
	:Aprender técnicas de depuración.
	:Resolver problemas comunes.
	:Proyecto Completo:
	:Desarrollar un proyecto de juego completo desde cero hasta el lanzamiento.
*LAS SEÑALES
	:Las señales son EVENTOS.
	:Son mensajes que se mandan al juego cuando algo ocurre.
	:Cuando se presiona un boton, cuando se suelta, cuando
	:se entra en un area o se sale, cuando se salta, etc.
	:-
	:Tienen dos partes
	:-
	:EMISORES
	:Son los controles que disparan el EVENTO o SEÑAL
	:-
	:INSCRIPCIONES
	:Son los objetos que se inscriven en a esa EMISION
	:para reaccionar ante ella.
	:-
	:Podemos conectar señales de dos modos.
	:Por Codigo o con el panel.
	:-
	:POR PANTALLAS
	:Cuando selecionamos un control.
	:En la parte de la derecha nos aparecen los eventos que
	:tiene.
	:Selecionamos el evento que queremos que se publique.
	:En la parte inferior selecionamos CONNECT
	:Se nos muestra una pantalla donde le decimos el nodo
	:que escuchara el evento y le damos un nombre de funcion
	:que respondera a ese evento
	:-
	:POR CODIGO.
	:En este punto podemos o usar y enlazar una señal existente.
	:Como el caso del MouseUp.
	:O podemos crear nosostros una señal propia para un control.
	:-
	:SEÑAL PROPIA.
	:-Primero en el control definimos la señal en la cabecera del script.
	:signal hit; # sin parametros
	:signal hit(value1,Value2,ValueX); #multiples parametros.
	:- En el propio control definimos una funcion que disparara el evento
	:emit_signal("hit",Valor);
	:-En el control que queremos que responda enlazamos la señal con
	:Control.Señal.connect(funcion);
	:-En el control tenemos que crear la funcion que respondera a ese
	:conect.
	:-
	:-DE FORMA DINAMICA
	:- Creamos un boton que tenga el evento personalizado.
	:- Lo llamamos y creamos una tabla de ese boton.
	:- Asociamos el evento.
	:-
	:- EN EL PADRE
	:-
	:var M_SCN_REPO=preload("res://SCN_EVENTOS_REPO/SCN_REPO.tscn").instantiate();
	:var M_BtClon=M_SCN_REPO.get_node("REPO_BTBase");
	:-
	:while (M_q<20):
	:·tvar M_Bt:Button=M_BtClon.duplicate();
	:·tM_Bt.name="BT"+str(M_q);
	:·tM_Bt.text=M_Bt.name;
	:·tV_TBt.append(M_Bt);
	:·t#
	:·tself.add_child(M_Bt);
	:·tM_Bt.set_size(M_Size,false);
	:·tM_Bt.visible=true;
	:·tM_Pos.x=M_q*50;
	:·tM_Bt.set_position(M_Pos);
	:·tM_q+=1;
	:#EndWhile
	:M_q=0;
	:while (M_q<20):
	:·tvar M_Bt:Button=V_TBt[M_q];
	:·tV_TBt[M_q].connect("MI_Evt_MouseUp",
	:·tCallable(self, "F_EVT_Bt_MouseUp"));
	:·tM_q+=1;
	:#EndWhile
	:-
	:func Evt_Button_MouseUp(SELF):
	:·tF_Tron(SELF.name+".Evt_Button_MouseUp");
	:#end Func Evt_Button_MouseUp
	:-
	:-
	:EL BOTON A CLONAR
	:-
	:signal MI_Evt_MouseUp(SELF);
	:-
	:func _ready()->void:
	:·tself.button_up.connect(Evt_Button_Up)
	:-
	:func Evt_Button_Up():
	:·tself.emit_signal("MI_Evt_MouseUp",self)
	:-
	:MODO DIRECTO
*LAS SEÑALES BASE
	:En godot las SEÑALES son parecidas a los EVENTOS pero
	:un poco mas flexibles.
	:Es un poco lioso.
	:Por defecto el control base del godot tiene algunos
	:eventos de fabrica como son button_down button_up
	:Pero tambien podemos crear eventos propios.
	:-
	:Tenemos tres partes.
	:Crear la señal o evento (algunos ya existen por defecto.)
	:Disparar el evento.
	:Conectar con un evento.
	:-
	:Es posible crear, enlazar y disparar eventos desde cualquier
	:control en cualquier control.
	:-
	:Para ello usa una estructura o funcion
	:Callable(DondeEstaLaFuncion,"NombreFuncion").
	:-
	:## CREAR SEÑAL o EVENTO ##
	:signal EVT_CLICK(DAT1,DAT2,DAT3);
	:NT:Podemos pasar en DAT el propio control
	:-
	:## EMITIR una SEÑAL. ##
	:self.emit_signal("NOMBRE EVENTO",PARAMETRO);
	:-
	:## CONECTAR a una SEÑAL ##
	:self.connect("NOMSEÑAL",
	:Callable(LUGAR_FUNCION,"NOMBRE_FUNCION"),
	:CONNECT_PERSIST);
	:-
	:-
	:Ejemplo:
	:En este ejemplo creo un evento mio "EVT_CLICK(self)" en un
	:button.
	:Enlazo el evento "button_up" del propio boton a una funcion
	:"EVT_Click()" y esta funcion dispara mi evento "EVT_CLICK(self)"
	:En el script de la escena capturo los dos eventos.
	:el propio de button "button_up" y el "EVT_CLICK"
	:y Disparo una funcion para cada evento del boton,
	:el propio y el mio.
	:-
	:BOTON
	:-
	:extends Button
	:signal EVT_CLICK(SELF);
	:func _ready():
	:·tself.connect("button_up",
	:·tCallable(self,"EVT_Click"),
	:·tCONNECT_PERSIST);
	:#END _READY
	:func EVT_Click():
	:·tself.emit_signal("EVT_CLICK",self);
	:·tself.text="Click";
	:#END EVT
	:func _process(delta):
	:pass
	:-
	:ESCENA
	:-
	:extends Control
	:func _ready():
	:·t#Enlazo a mi Evento
	:·t$ColorRect/Button.connect("EVT_CLICK",
	:·tCallable(self,"EVT_Clik"));
	:·t#Enlazo a un evento base
	:·t$ColorRect/Button.connect("button_up",
	:·tCallable(self,"EVT_Up"));
	:#END _ready
	:func EVT_Clik(SELF):
	:·tif (SELF is Button):
	:·t·tprint("SCN.EVT_Clic");
	:·t#EndIF
	:#END EVT
	:func EVT_Up(SELF):
	:·tif (SELF is Button):
	:·t·tprint("SCN.EVT_Up");
	:·t#EndIF
	:#END EVT
	:func _process(delta):
	:·tpass
	:-
	:Si lo que queremos es enlazar un evento existente con una
	:funcion propia tenemos que añadir al evento y usar bind para
	:pasar parametros.
	:En este ejemplo, Creamos un boton y enlazamos su
	:evento Button_up con nuestro EVT_on_Button_up y le
	:decimos que pase el propio boton.
	:En el EVT le digo que imprima el nombre del boton que
	:lanzo el evento.
	:-
	:func _ready():
	:·tF_GetBt("BtChuflo");
	:#END func _ready
	:func F_GetBt(MName:String)->Button:
	:·tvar MBt:Button=Button.new();
	:·tMBt.name=MName;
	:·tMBt.text="XX..";
	:·t$PanBase/ScrollContainer/HBoxContainer/VBC_Right.add_child(MBt);
	:·tMBt.button_up.connect(EVT_on_button_up.bind(MBt));
	:·treturn MBt;
	:#END F_GetBt(MName:String)
	:func EVT_on_button_up(SELF:Button):
	:·tprint("ES BUTTON"+SELF.name);
	:#END _on_button_up
*LENGUAJE
	:Es muy parecido a pyton con algunas diferencias.
	:Permite multilineas.
	:Podemos terminar las sentencias con ; o si estan solas
	:en la linea no poner nada.
	:Usa <Tab> para los bloques de codigo.
*Materiales
*MULTI IDIOMA
	:El godot tiene un modo muy simple para trabajar el texto en
	:multi idioma.
	:Podemos usar el excel aunque el usa un fichero con campos
	:separados por ",".
	:El fichero tiene en la primera fila una columna con "id" y
	:las siguientes columnas con los idiomas ("es","en")
	:En el id tendremos el texto real que tiene el control.
	:En la coumna de "es" el texto en español y
	:en el texto en ingles a remplazar.
	:Imagina que tienens un control que se llama
	:"label_accion" y tiene el texto "KeyStr_comer"
	:la tabla seria esta,
	:-
	:id,en,es
	:KeyStr_Comer,Comer,Eat.
	:-
	:Este fichero se lo importas al godot.
	:el lo trascibe a tantos ficheros como idiomas tengas en el fichero.
	:El fichero que el genera esta comprimido y cifrado.
	:Es posible definir si quieres que el texto este separado
	:por "," por "tab" o por ";".
	:-
	:Despues en project settings/localization añadimos
	:los ficheros ".transation" que ha generado para que
	:godot sepa donde estan para todo el proyecto.
	:-
	:Dentro para indicarle cual es el "Texto_Key" usaremos
	:lable_accion.text = TR("KyeStr_Comer");
	:de ese modo le indicaremos que tienen que transcribir en ese
	:control ese texto a los idiomas que tengas.
	:-
	:Para selecionar el idioma usaremos el comando:
	:TranslationServer.set_locate("en")
	:esto le indica que desde ese momento la columna/fichero
	:que usara sera el de ingles, NT: en y es es el tiulo de las
	:columnas con los idiomas.
*NODO
	:-PROPIEDADES
	:String·t<-·teditor_description·t""
	:MultiplayerAPI·t<-·tmultiplayer
	:StringName·t<-·tname
	:Node·t<-·towner
	:ProcessMode·t<-·tprocess_mode·t0
	:int·t<-·tprocess_physics_priority·t0
	:int·t<-·tprocess_priority·t0
	:ProcessThreadGroup·t<-·tprocess_thread_group·t0
	:int·t<-·tprocess_thread_group_order
	:BitField<ProcessThreadMessages>·t<-·tprocess_thread_messages
	:String·t<-·tscene_file_path
	:bool·t<-·tunique_name_in_owner·tfalse
	:Methods¶
	:void·t<-·t_enter_tree ( ) virtual
	:void·t<-·t_exit_tree ( ) virtual
	:PackedStringArray·t<-·t_get_configuration_warnings ( ) virtual const
	:void·t<-·t_input ( InputEvent event ) virtual
	:void·t<-·t_physics_process ( float delta ) virtual
	:void·t<-·t_process ( float delta ) virtual
	:void·t<-·t_ready ( ) virtual
	:void·t<-·t_shortcut_input ( InputEvent event ) virtual
	:void·t<-·t_unhandled_input ( InputEvent event ) virtual
	:void·t<-·t_unhandled_key_input ( InputEvent event ) virtual
	:void·t<-·tadd_child ( Node node, bool force_readable_name=false, InternalMode internal=0 )
	:void·t<-·tadd_sibling ( Node sibling, bool force_readable_name=false )
	:void·t<-·tadd_to_group ( StringName group, bool persistent=false )
	:Variant·t<-·tcall_deferred_thread_group ( StringName method, ... ) vararg
	:Variant·t<-·tcall_thread_safe ( StringName method, ... ) vararg
	:bool·t<-·tcan_process ( ) const
	:Tween·t<-·tcreate_tween ( )
	:Node·t<-·tduplicate ( int flags=15 ) const
	:Node·t<-·tfind_child ( String pattern, bool recursive=true, bool owned=true ) const
	:Node[]·t<-·tfind_children ( String pattern, String type="", bool recursive=true, bool owned=true ) const
	:Node·t<-·tfind_parent ( String pattern ) const
	:Node·t<-·tget_child ( int idx, bool include_internal=false ) const
	:int·t<-·tget_child_count ( bool include_internal=false ) const
	:Node[]·t<-·tget_children ( bool include_internal=false ) const
	:StringName[]·t<-·tget_groups ( ) const
	:int·t<-·tget_index ( bool include_internal=false ) const
	:Window·t<-·tget_last_exclusive_window ( ) const
	:int·t<-·tget_multiplayer_authority ( ) const
	:Node·t<-·tget_node ( NodePath path ) const
	:Array·t<-·tget_node_and_resource ( NodePath path )
	:Node·t<-·tget_node_or_null ( NodePath path ) const
	:Node·t<-·tget_parent ( ) const
	:NodePath·t<-·tget_path ( ) const
	:NodePath·t<-·tget_path_to ( Node node, bool use_unique_path=false ) const
	:float·t<-·tget_physics_process_delta_time ( ) const
	:float·t<-·tget_process_delta_time ( ) const
	:bool·t<-·tget_scene_instance_load_placeholder ( ) const
	:SceneTree·t<-·tget_tree ( ) const
	:String·t<-·tget_tree_string ( )
	:String·t<-·tget_tree_string_pretty ( )
	:Viewport·t<-·tget_viewport ( ) const
	:Window·t<-·tget_window ( ) const
	:bool·t<-·thas_node ( NodePath path ) const
	:bool·t<-·thas_node_and_resource ( NodePath path ) const
	:bool·t<-·tis_ancestor_of ( Node node ) const
	:bool·t<-·tis_displayed_folded ( ) const
	:bool·t<-·tis_editable_instance ( Node node ) const
	:bool·t<-·tis_greater_than ( Node node ) const
	:bool·t<-·tis_in_group ( StringName group ) const
	:bool·t<-·tis_inside_tree ( ) const
	:bool·t<-·tis_multiplayer_authority ( ) const
	:bool·t<-·tis_node_ready ( ) const
	:bool·t<-·tis_physics_processing ( ) const
	:bool·t<-·tis_physics_processing_internal ( ) const
	:bool·t<-·tis_processing ( ) const
	:bool·t<-·tis_processing_input ( ) const
	:bool·t<-·tis_processing_internal ( ) const
	:bool·t<-·tis_processing_shortcut_input ( ) const
	:bool·t<-·tis_processing_unhandled_input ( ) const
	:bool·t<-·tis_processing_unhandled_key_input ( ) const
	:void·t<-·tmove_child ( Node child_node, int to_index )
	:void·t<-·tnotify_deferred_thread_group ( int what )
	:void·t<-·tnotify_thread_safe ( int what )
	:void·t<-·tprint_orphan_nodes ( ) static
	:void·t<-·tprint_tree ( )
	:void·t<-·tprint_tree_pretty ( )
	:void·t<-·tpropagate_call ( StringName method, Array args=[], bool parent_first=false )
	:void·t<-·tpropagate_notification ( int what )
	:void·t<-·tqueue_free ( )
	:void·t<-·tremove_child ( Node node )
	:void·t<-·tremove_from_group ( StringName group )
	:void·t<-·treparent ( Node new_parent, bool keep_global_transform=true )
	:void·t<-·treplace_by ( Node node, bool keep_groups=false )
	:void·t<-·trequest_ready ( )
	:Error·t<-·trpc ( StringName method, ... ) vararg
	:void·t<-·trpc_config ( StringName method, Variant config )
	:Error·t<-·trpc_id ( int peer_id, StringName method, ... ) vararg
	:void·t<-·tset_deferred_thread_group ( StringName property, Variant value )
	:void·t<-·tset_display_folded ( bool fold )
	:void·t<-·tset_editable_instance ( Node node, bool is_editable )
	:void·t<-·tset_multiplayer_authority ( int id, bool recursive=true )
	:void·t<-·tset_physics_process ( bool enable )
	:void·t<-·tset_physics_process_internal ( bool enable )
	:void·t<-·tset_process ( bool enable )
	:void·t<-·tset_process_input ( bool enable )
	:void·t<-·tset_process_internal ( bool enable )
	:void·t<-·tset_process_shortcut_input ( bool enable )
	:void·t<-·tset_process_unhandled_input ( bool enable )
	:void·t<-·tset_process_unhandled_key_input ( bool enable )
	:void·t<-·tset_scene_instance_load_placeholder ( bool load_placeholder )
	:void·t<-·tset_thread_safe ( StringName property, Variant value )
	:void·t<-·tupdate_configuration_warnings ( )
*NODOS - ANIMATION PLAYER
	ª10035ª10032
	:Este nodo se enlaza a otro nodo sobre el que puede animar
	:cualquier propiedad de cualquier nodo.
	:Podemos por ejemplo crear las animaciones de unos
	:sprites.
	:Tambien nos permite añadir ALERTAS en fotogramas
	:de este modo podemos dar sonido de pasos cuando el
	:sprite pise el suelo.
	:Para añadir los fotogramas claves pincharemos en el icono
	:de llave al lado de la propiedad del control padre.
	:Un AnimationPlayer puede tener muchas animaciones distintas.
	:EJ:
	:Añadimos un nodo Sprite2d y dentro añadimos un AnimationPlayer.
	:En la parte inferior nos mostrara el panel de animacion "aunque
	:tengamos selecionado el sprite2D."
	:Le damos una duracion y nos colocamos en el fps 0.
	:Ahora en las propiedades del sprite2D arrastramos el sprite
	:a la propiedad "Texture" y boton de llave.
	:Y listo ya tenemos el primer fotograma clave.
	:Selecionamos el sigueinte FK, arrastramos y llave.
	:Asi todos fps de la animacion.
	:-
	:En el caso de ser todos los sprites en un solo grafico.
	:En la seccion "Animation" del "Sprite2D" le indicamos el tamaño
	:de cada recuadro y el "OffSet" para despalzar el inicio.
	:Al selecionar el Fotograma0 y Clickar en las llaves de Frame.
	:Selecionara la porcion y selecionara a siguiente porcion.
	:-
	:Tambien podemos indicar que animaciones funcionan el LOOP
	:o ciclicas Activando la doble flecha en el panel del AnimationPlayer.
	:-
	:Por medio del GDScript podemos manejar la animacion, saber
	:en que fotograma esta y demas.
	:Estos EVENTOS o SEÑALES nos indican que animacion disparo
	:esa SEÑAL.
	:Tambien podemos crear una funcion y llamarla desde el
	:ANIMATIONPLAYER en un FPS concreto.
	:(En el ANIMPLY Añadimos una pista de CALL Metod Trak,
	:Le indicamos donde esta la funcion, y
	:Tambien podemos premarar Eventos o Alertas en fotogramas claves
	:para que realize tareas especificas..
*NODOS - ANIMATIONTREE
	ª10033ª10030ª10027ª10029ª10031
	:AnimationTree o Arblo de animaciones.
	:Este nodo nos permite enlazar un AnimationPlayer con
	:una maquina de estados.
	:La maquina de estados nos permite de forma visual
	:crear distintos estados mostrando distintas animaciones
	:en cada estado y pasando de un estado a otro.
	:-
	:Una maquina de estados tiene que estar atada a un
	:AnimationPlayer.
	:-
	:Primero necesitamos un "AnimatioPlayer" con distintas
	:Animaciones.
	:Imaginemos un Keko que partulla.
	:1- Anda hasta X posicion
	:2- Para y mira durante un rato
	:3- Si encuentra algo dispara.
	:4- Si no regresa a 1 y asi.
	:-
	:Tenemos que tener un AnimationPlayer con
	:distintas animaciones.
	:Le añadimos al sprite2D el nodo del AnimationTree
	:Le decimos al AnimationTree que es de tipo
	:AnimationNodeStateMachine.
	:Le decimos que su AnimPlayer es el nuestro.
	:Y por ultimo lo "Activamos" OJO: esto hace que el
	:AnimationTree Tome el control del AnimationPlayer
	:por lo que el codigo añadido para su control ya no
	:funcionara.
	:-
	:Al selecionarlo nos mostrara un panel con cuadros y dos
	:cuadros por defecto. "STAR" y "END"
	:Con el boton derecho o con el boton "+" en la parte superior
	:podemos añadir las animaciones del AnimationPlayer.
	:-
	:Ahora uniremos vinculos entre el "START" y las distintas
	:animaciones de forma que salte de
	:PJ: de Andar a mirar a disparar y regrese a andar.
	:-
	:Podemos indicar el tipo de transacion si queremos que:
	:Sea Inmediata, Cuando termine una animacion o , Sincronizada.
	:Para 2D se suele usar Inmediata o Cuando termine.
	:Tambien podemos modificar los parametros de un vinculo
	:selecionandolo.
	:E incluso añadir scripts.
	:-
	:Podemos acceder y modificar las animaciones que se estan
	:ejecutando accediendo al control.
	:-
	:extends Node2D
	:@onready var V_PlayBack:AnimationNodeStateMachinePlayback=$Sprite2D/AnimationTree.get("parameters/playback");
	:func _ready():
	:_ V_PlayBack.travel("RUN");
	:#end func _ready
	:func F_GetAnimTr_GetPlayBack():
	:_ var M_Node=V_PlayBack.get_current_node();
	:_ if(M_Node=="Run_I"):print("RUN");
	:_ elif(M_Node=="Hidle_L"):print("Hidle");
	:_ elif(M_Node=="Step_L"):print("Step");
	:_ elif(M_Node=="GunA_L"):print("Gun");
	:_ else:
	:_ # EndIf
	:#End func F_GetStMach_GetEstado
	:-
	:@onready -> carga la variable cuando ya se ha ejecutado la
	:burbuja de readys.
*NODOS 2D
	:Los NODOS es es componente basico de GODOT.
	:El NODO tiene propiedades basicas a las que
	:se le añaden otras propiedades para formar de
	:este modo por capas otros nodos.
	:Ejemplo:
	:el NODO basico tiene
	:PROCESS
	:SCRIPT
	:-
	:El NODO 2D tiene lo del NODO mas
	:TRANSFORM
	:VISIBILITY
	:ORDERING
	:TEXTURE
	:MATERIAL
	:-
	:El NODO 3D tiene lo del NODO mas
	:TRANSFORM
	:VISIBILITY
	:-
	:En GODOT tenemos 3 tipos de nodos.
	:Node2D de tipo Canvas
	:Control de tipo Canvas
	:Node3D
	:-
	:Tambien tenemos otros nodos que sirven de ayudantes para
	:controlar audio, multiplayer, conexion http y los que instalemos
	:para propositos especificos.
	:-
	:LISTA DE NODOS Y RESUMEN.
	:-
	:- NODE2D
	:Realiza operaciones basicas para colorar un objeto 2D un Sprite.
	:- CAMERA2D
	:Controla el marco de vision 2D para hacer scrool y aplicar algun filtro.
	:-Sprite2D
	:Representa un grafico o textura en pantalla con propiedades basicas.
	:-AnimatedSprite2D
	:Representa una secuencia de Sprite2D haciendo una animacion
	:-CollisionShape2D
	:Controla las colisiones de un objeto 2D, Tambien maneja las fisicas del objeto.
	:Necesita estar en un contenedor.
	:-StaticBody2D
	:Agrupa en un cuerpo estatico otros nodos como un sprite2D y un CollisionShape2D
	:Este "Contenedor" NO es mobible
	:-AnimatableBody2D
	:Agrupa en un cuerpo estatico otros nodos como un sprite2D y un CollisionShape2D
	:Este "Contenedor" SI es mobible afectando las fisicas de los otros nodos.
	:-RigidBody2D
	:Es igual que StaticBody2D pero afecta y es afectado por otros nodos
	:Tiene mas fisicas pudiendo no solo tener grabedad , tambien permite rotar y empujar.
	:-CharacterBody2D
	:Tambien es un contenedor pero tiene las funciones propias para
	:controlar un personaje , acepta entrada del teclado y tiene las funciones
	:para desplazar al personaje etc.
	:-GrooveJoin2D
	:Conecta dos nodos y solo deja  que se desplace uno al empujarlo en un eje.
	:-DanpedSpringjoin2D
	:Conecta dos nodos y les aplica fisicas de resorte,(Atados por cuerda o goma)
	:-PinJoint
	:Conecta dos nodos y permite que uno rote como puerta sobre el eje.
	:-Area2D
	:Intercepta que nodos estan o atrabiesan ese area."Caja de colision"
	:-AudioListener2D
	:Permite definir desde donde sale un sonido.
	:-GPUParticles2D
	:-CPUParticles2D
	:Permiten generar y emitir particulas.
	:-TileMap
	:Genera una cuadricula para colocar mapas 2D "grill"
	:Tiene erramientas propias para definir los sprites, animaciones etc.
	:-CanvasModulate
	:Permite configurar efectos en los mapas 2D, dando sombras o tiñendo
	:el mapa.
	:-Light2D
	:Simula un punto de luz en el mundo 2D pudieno dar brillo ofuerza de
	:color.
	:-PointLight2D
	:Simula un punto de luz, es necesario darte una textura para que
	:sepa aplicar sombras de forma radial
	:-DirectionalLight2D
	:Simula un punto de luz, es necesario darte una textura para que
	:sepa aplicar sombras de forma lineal
	:-LightOccluder2D
	:Es un bloque que poryecta sombras .
	:-Line2D
	:Permite añadir lineas vectoriales
	:-Marker2D
	:Es solo una marca 2D es un ayudante con una posicion y una rotacion.
	:-MeshInstance2D
	:Representa un objeto 3D en 2D
	:-MultiMeshInstance2D
	:Lo mismo que MeshInstance2D pero con muchas mayas.
	:-NavigationRegion2D
	:Permite definir un mapa para que personajes solo se desplacen
	:por esa region
	:-ParalaxBackGrouns
	:-ParalaxLayer
	:Definen un grafico para que sea la capa de fondo y se scroole
	:segun se desplace la camra.
	:-Path2D
	:-PathFollow2D
	:Definen unas lineas vectoriales para que luego otro nodo las recorra
	:punto a punto, podemos definir las subdibisiones y demas.
	:-Poligon 2D
	:Permite crear un nodo con poligonos podemos deformar el poligono
	:tanto como queramos.
	:-RayCast2D
	:Es una linea que se dispara cuando algun nodo colisiona con
	:dicha linea.
	:-ShapeCast2D
	:Es un grupo de lineas que se dispara cuando un nodo
	:colisiona con alguna de las lineas
	:-RemoteTransform2D
	:Es un nodo capaz de manipular las porpiedades de otro nodo.
	:-Skeleton2D
	:-PhysicalBone2D
	:-Bone2D
	:Esto se usa para hacer esqueletos en 2D Brazos, Piernas Cabeza
	:y asi crear un muñeco animado.
	:-VisibleOnScreenNotifier2D
	:-VisibleOnScreenEnabled2D
	:Son disparadores que indican si un determinado nodo esta visible
	:en la pantalla, segun la camara.
	:-CanvasGroup
	:Permite agrupar distintas Canvas o texturas y trabajarlas como si
	:fuesen un grupo con una sola colision y demas.
	:-BackBufferCopy
	:Permite copiar parte de la pantalla y crear una textura para
	:usarla donde queramos.
*NODOS 3D
	:-Node3D
	:Contiene las propiedades mas basicas de un nodo en 3D
	:Seria como un pixel en 3D
	:-Marker3D
	:Es una marca en 3D se usa como ayudante.
	:-VisualInstance3D
	:Permite agrupar Marcacores.
	:-GeometryInstance3D
	:Permite agrupar geometria pudiendo modificar sus
	:texturas, iluminaciones,lods y posprocesados.
	:-MeshInstance3D
	:Permite definir una maya o un poligono con sus
	:propiedades.
	:-MultiMeshInstance3D
	:Permite agrumar muchas mayas como pelo o cesped.
	:Es complejo y tiene su editor.
	:-Label3D
	:Permite definir un texto en 3D.
	:-Decal
	:Permite poryectar una textura sobre un objeto
	:a modo de calcomania.
	:-AnimatedSprite3D
	:-Sprite3D
	:Permite añadir Sprites o animaciones de sprites en
	:el mundo 3D
	:-WorldEnvironment
	:Permite definir y configurar la iluminacion del entorno
	:Tambien puede aplicar efectos y filtros.
	:-FogVolume
	:Permite aplicar niebla a un espacio.
	:-GPUParticles3D
	:Es un generador de particulas por GPU
	:Esta muy relacionado con el WorldEnvironment
	:-GPUParticlesAttractor3D
	:-GPUParticlesCollision3D
	:Junto con las particulas estos nodos son un
	:bolumen colisionador y Atractor (atrae) las particulas.
	:-Light3D
	:Es un configurador de las propiedades de la luz.
	:No es una luz en si misma.
	:-OmniLight3D
	:Es un emisor de luz tipo esfera.
	:-SpotLight3D
	:Es un emisor de luz tipo cono.
	:-DirectionalLight3D
	:Es un emisor de luz tipo sol. No ajusta una posicon
	:Es mas bien la luz y sombras en posicion del sol .
	:-CSGShape3D
	:Son poligonos que deforman otros poligonos aplicando
	:operaciones booleanas para su deformacion,
	:Union, Sustracion y diferencia.
	:Son muy practicas para trabajar colisiones.
	:-SoftBody3D
	:o Cuerpo blando permite simular telas.
	:-CollisionObject3D
	:Trabaja junto con otros nodos y permite definir o
	:actuar cuando otro nodo colisione con este
	:-PhisicsBody3D
	:Trabaja junto con otros nodos y permite dotar a
	:sus hijos de propiedades fisicas pudiendo limitar
	:rotaciones o dar grabedad etc.
	:-CollisionPoligon3D
	:-CollisionShape3D
	:Trabaja junto con otro nodo y permite detectar
	:colisiones sobre un poligono dado o sobre una
	:maya dada.
	:-StaticBody3D
	:Permite crear cuerpos estaticos que no se podran
	:mover ni seran afectados por otros objetos.
	:(Se muede mover pero no afectara las fisicas de otros objetos)
	:-AnimatableBody3D
	:Este objeto si se puede mover y afecta a las fisicas
	:de otros objetos.
	:-RigidBody3D
	:Estos objetos se afectan y son afectados por otros objetos
	:y tienen fisicas.
	:-CharacterBody3D
	:Es el objeto creado para ser controlado y tiene ya las
	:fisicas propias de un personaje.
	:-Area3D
	:Detecta cuando un objeto esta dentro o sale
	:y Permite definir areas y zonas con sonidos y efectos especiales
	:(debajo del agua, una cueba etc)
	:-Camera3D
	:Permite representar distintos puntos de vista en el espacio 3D
	:-VehicleWheel3D
	:-VehicleBody3D
	:Al igual que el CharacterBody3D tiene las fisicas propieas para
	:simular un coche.
	:-Join3D
	:Permite hacer uniones de objetos
	:-HingeJoin3D
	:Permite simular las fisicas de una bisagra.
	:-ConeTwistJoin3D
	:Permite simular las fisicas de un pivote.
	:-SliderJoin3D
	:Permite el desplazamiento de un objeto sobre otro en un
	:solo eje como un piston
	:-PinJoin3D
	:Permite unir dos objetos dando fisica a uno sobre otro como
	:si estubiesen atados por una cuerda.
	:-Generic6DOFjoin3D
	:Como todos los anteriores permite definir todos los
	:parametros de union y flexibilidad de un objeto sobre otro.
	:-Skeleton3D
	:Es un esqueleto, maneja uniones complejas entre muchos
	:objetos y sus relaciones con otros.
	:-BoneAttachment3D
	:Permite atar otro objeto a un hueso de un skeleto
	:-RootMotionView
	:Es solo un ayudante que muestra una rejilla.
	:-VoxelGI
	:Es el mas pesado y calcula todo a tiempo real, una vez
	:creada la escena
	:-LightMapProbe
	:-LightMapGI
	:-
	:-ReflectionProbe
	:Captura los objetos a su alrededor y genera un mapa
	:de feflejos sobre el objeto simulando un espejo.
	:-ImporterMeshInstance3D
	:Aun no se sabe que hace.
	:-VisibleOnScreenNotifier3D
	:-VisibleOnScreenEnabled3D
	:Detecta cuando un nodo es visible por la camara en un
	:area dada.
	:-GridMap
	:Genera una rejilla en 3D para colocar Meshes y construir
	:un mapa.
	:-AudioListener3D
	:Le indica al juego cual sera el punto de escucha
	:del sonido . por defecto es la camara.
	:-AudioStreamPlayer3D
	:Proyecta un sonido o musica en un punto 3D
	:-NavigationRegion3D
	:Es un objeto que genera un mapa de navegacion para que
	:la ia sepa por donde moverse.
	:-OccluderInstance3D
	:Permite ocultar objetos que no son visibles por estar ocultos
	:detras de otros.
	:-Path3D
	:-PathFollow3D
	:Permite crear una linea dividida y recorrera en un tiempo.
	:-RayCast3D
	:Traza una linea y captura que objetos cortan esa linea.
	:-ShapeCast3D
	:Traza un rombo donde caputra que objetos entran y salen.
	:-SpringArm3D
	:Es un RayCast3D pero ajusta su tamaño si encuentra una
	:colision de modo que el largo del brazo es el maximo que
	:pueda sin colisionar.
	:-RemoteTransform3D
	:Permite copiar las transformaciones de un nodo a otro nodo.
	:-XROrigin3D
	:-XRAnchor3D
	:-XRController3D
	:-XRNode3D
	:Se usan para controlar juegos VR
*-NODOS CONTROL
	:-Container
	:Contenedor Basico (panel)
	:-TextureRect
	:Una textura rectangular, La extura se ajusta en tamaño
	:-VBOXContainer
	:-BoxContainer
	:-HBoxContainer
	:Cajas columnas y filas automaticas.
	:-CenterContainer
	:Ajusta el contenido en el centro conservando el tamaño
	:-FlowContainer
	:-HFlowContainer
	:-VFlowContainer
	:Ajusta el contenido segun el tamaño de los objetos.
	:Si es muy ancho lo salta de linea y si entra en la
	:linea anterior los sube.
	:-GridContainer
	:Ajusta los objetos contenidos segun una configuracion
	:de columnas. 3Columnas X XFilas.
	:-SplitContainer
	:-HSplitContainer
	:-VSplitContainer
	:Es una barra que permite ajustar el tamaño de los paneles
	:de los lados .
	:-MarginContainer
	:Es un panel que permite definir un espaciado.
	:-PanelContainer
	:Es el panel mas basico.
	:-ScrollContainer
	:Es un panel que permite mostrar mas de lo que se muestra
	:mostrando barras de scrool.
	:-TabContainer
	:Permite mostrar distintos paneles segun el boton pinchado
	:(Un Tab Basico)
	:-Label
	:Es un texto simple.
	:-RichTextLabel
	:Permite mostrar texto enriquezido con negritas subrallados.
	:-ColorRect
	:Un cuadro de un color
	:-TextureRect
	:Es un grafico dibujo o textura
	:-VideoStreamPlayer
	:Permite mostrar un video o animacion en un recuadro.
	:-HSeparator
	:-VSeparator
	:Es una linea de separacion entre dos controles
	:-Panel
	:Es un panel contenedor que se puede poner en cualquier sitio
	:-NinePathRect
	:Es un panel que permite configurar texturas para esquinas,
	:bordes y fondo pudiendo reescalarlo y conservando los
	:bordes bien.
	:-Button
	:-BaseButton
	:-TextureButton
	:Un control con texto que permite acciones de entrada como
	:click
	:-LinkButton
	:Es un texto al estilo de los link del Internet Explorer
	:que lanza el navegador web a una direcion
	:-ChekBox
	:-CheckButton
	:Permite y mantiene el estado de un chek On Off
	:-MenuButton
	:Al pulsarlo mostrara un menu desplegable para
	:que se pueda decidir entre una u otra opcion
	:-OptionButton
	:Tambien muestra una lista pero en este caso
	:permite chekear una opcion que pasa a ser la opcion
	:selecionada. (La opcion Selecionada)
	:-ColorPickerButton
	:Boton que lanza un panel de selecion de colores y lo
	:establece.
	:-LineEdit
	:Es un cuadro donde introducir un texto. (TextBox)
	:-TextEdit
	:-CodeEdit
	:Es un cuadro de texto con o sin codigo donde se
	:edita gcode
	:-Range
	:Es una barra donde se define un valor al desplazarla.
	:-ProgresBar
	:-TextureProgresBarr
	:Mostrara una barra iluminada X% o un grafico X%
	:-SpinBox
	:Es un cuadro de texto con dos flechas para subir o bajar el valor
	:-HScrollBar
	:-VScrollBar
	:Barras de Scroll para decidir un valor.Muestra solo un punto
	:-HSlider
	:-VSlider
	:Igual que la HScrollBar pero mostranod el rango de 0 a X
	:-ItemList
	:Muestra una lista de elementos
	:-MenuBar
	:Configura una barra de menus con submenus
	:-TabBar
	:Muestra una fila de botones o barra de Tabs.
	:-ReferenceRect
	:Permite separar en Recuadros y poner notas a las cosas.
	:-Tree
	:Permite generar un arbol de controles .
	:-GraphNode
	:-GraphEdit
	:Pendienes de revision
	:-TouchScreenButton
	:Es un boton que acepta touch de la pantalla tactil.
*NOTIFICACIONES
	:Existe un evento que se dispara cuando ocurre algo y podemos
	:capturar que ocurre por medio de constantes.
	:Segun donde capturemos la notificacion significara una cosa.
	:-
	:En un fichero instanciado globals. capturaremos lo ultimo
	:en ejecutarse y otros errores y mensajes.
	:Algunos de ellos seran:
	:-
	:func _notification(msg):
	:_ #Al cerrar entran.
	:_ #6320>[main_menu]..Bt_Close
	:_ #6321>[globals]._Notification=17 NOTIFICATION_PROCESS
	:_ #6322>[globals]._Notification=11 NOTIFICATION_EXIT_TREE
	:_ #6328>[globals]._Notification=19 NOTIFICATION_UNPARENTED
	:_ #6328>[globals]._Notification=1 Nose
	:_
	:_ if(msg == NOTIFICATION_WM_CLOSE_REQUEST):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_WM_CLOSE_REQUEST",self,true);
	:_ elif(msg == NOTIFICATION_CRASH):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_CRASH",self,true);
	:_ elif(msg == NOTIFICATION_APPLICATION_FOCUS_IN):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_APPLICATION_FOCUS_IN",self,true);
	:_ elif(msg == NOTIFICATION_WM_WINDOW_FOCUS_OUT):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_WM_WINDOW_FOCUS_OUT",self,true);
	:_ elif(msg == NOTIFICATION_WM_SIZE_CHANGED):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_WM_SIZE_CHANGED",self,true);
	:_ elif(msg == NOTIFICATION_OS_MEMORY_WARNING):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_OS_MEMORY_WARNING",self,true);
	:_ elif(msg == NOTIFICATION_NODE_RECACHE_REQUESTED):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_NODE_RECACHE_REQUESTED",self,true);
	:_ elif(msg == NOTIFICATION_WM_MOUSE_ENTER):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_WM_MOUSE_ENTER",self,true);
	:_ elif(msg == NOTIFICATION_UNPARENTED):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_UNPARENTED",self,true);
	:_ elif(msg == NOTIFICATION_EXIT_TREE):
	:_ _ f_log("_Notification=("+str(msg)+")NOTIFICATION_EXIT_TREE",self,true);
	:#END _notification
*OPERADORES MATEMATICOS
	:Son los simbolos que indican al motor que realizar
	:con los datos o variables.
	:-Los basicos serian:
	:+ = sumar
	:- = Restar
	:* = Multiplicacion
	:/ = Divison
	:-
	:-Los avanzados serian:
	:** = Obtiene el Exponente
	:% = Obtiene el Modulo
	:// = Obtienen una division entera.
	:+= = Incrementa en X una variable o numero.
	:-= = Decrementa en X una variable o numero.
*PATHs DE LA APP y DEL PERFIL
	:Para obtener la ruta donde el sistema guarda los ficheros
	:de las aplicaciones del usuario logueado usaremos la
	:Clase OS.
	:-
	:OS.get_data_dir();
	:#C:/Users/<USR>/AppData/Roaming
	:-
	:OS.get_user_data_dir();
	:#C:/Users/<USR>/AppData/Roaming/Godot/app_userdata/<JUEGO>
	:-
	:Si queremos saber donde esta el ejecutable del juego
	:usaremos tambien la clase OS
	:-
	:OS.get_executable_path();
	:#G:/[PRJS]/GODOT/Godot_v4.2-stable_win64/odot_v4.2-stable_win64.exe
	:-
	:OS.get_executable_path().get_base_dir();
	:#G:/[PRJS]/GODOT/Godot_v4.2-stable_win64
	:-
	:En este ejemplo guado las dos rutas
	:y creo en la ruta del usuario una carpeta
	:para guardar los saves.
	:Si no puedo crear la carpeta para los saves
	:cierro el juego con error.
	:-
	:func _ready():
	:·t#V.V_Path_Datos=OS.get_data_dir();#+"/"+"GAME1";
	:·t#F_log("<DATA DIR>",V.V_Path_Datos,0);
	:·tV.V_Path_Datos=OS.get_user_data_dir();
	:·tF_log("<USER DATA DIR>",V.V_Path_Datos,0);
	:·tV.V_Path_Datos=V.V_Path_Datos+"/GAME1";
	:·tF_log("<PathDatos>",V.V_Path_Datos,0);
	:·t#Si el directorio no existe lo intento crear
	:·tif (!DirAccess.dir_exists_absolute(V.V_Path_Datos)):
	:·t·tF_log("<BASE>","APP_PTH_ADD:"+V.V_Path_Datos,0);
	:·t·tDirAccess.make_dir_absolute(V.V_Path_Datos);
	:·t#END IF Creo USER DIR
	:·t#Si SI lo he creado definos los ficheros save si no SALGO
	:·tif (DirAccess.dir_exists_absolute(V.V_Path_Datos)):
	:·t·tF_log("<BASE>","APP_PTH_OK:"+V.V_Path_Datos,0);
	:·t·tV_Path_FileSave1=V.V_Path_Datos+"/Save1.db";
	:·t·tV_Path_FileSave2=V.V_Path_Datos+"/Save2.db";
	:·t·tV_Path_FileSave3=V.V_Path_Datos+"/Save3.db";
	:·t·tV_Path_FileSave4=V.V_Path_Datos+"/Save4.db";
	:·t·tF_log("<BASE>","SAVES_PTH_OK:"+V.V_Path_FileSave1,0);
	:·telse:
	:·t·tget_tree().quit(69);#Codigo de error propio retornado por salida no normal
	:·t#END IF ELSE USER DIR Creado/Existe
	:·t#V.V_Path_App=ProjectSettings.get_setting("application/config/name");
	:·t#V.V_Path_App=ProjectSettings.globalize_path("");
	:·t#OS.get_executable_path(); #Retorna la ruta completa + el ejecutable
	:·tF_log("<BASE>","PTH_APP:"+V.V_Path_App,0);
	:·t#OS.get_executable_path().get_base_dir(); # Retorna solo la ruta sin el ultimo /
	:·tV.V_Path_App=OS.get_executable_path().get_base_dir()+"/"; #.path_join("hello.txt")
	:·tF_log("<BASE>","PTH_APP:"+V.V_Path_App,0);
	:#END _Ready
*Pausar Nodos
	:# Pausar la escena completa
	:get_tree().paused = true
	:# Pausar un nodo específico y sus hijos
	:mi_nodo.paused = true
	:# Pausar una parte de la lógica del juego
	:func _process(delta):
	:if not pausado:
	:# Ejecutar lógica del juego normalmente
	:# ...
	:# Llamar a esta función para pausar o reanudar la lógica del juego
	:func pausar_juego(pausado):
	:if get_tree().paused != pausado:
	:get_tree().paused = pausado
*PRIMER CONTACTO
	ª10000
	:El primer contacto te abre el editor en modo 3D.
	:-
	:En la parte central superior nos muestra las distintas plantillas.
	:- 2D para juegos 2D o ventanas.
	:- 3D para juegos 3D.
	:- Script para programar la logica.
	:- AssetLibs para librerias importadas.
	:-
	:En la parte derecha superior tenemos
	:las opciones de ejecucion y renderizado.
	:-
	:En la parte izquierda superior tenemos
	:los menus para editar crear modificar y configurar tanto
	:el entorno como las escenas.
	:-
	:En la parte de la izquierda superior
	:-Escena - Añadimos nodos a la escena.
	:-Importar - Al selecionar un fichero importable nos
	:mostrara las opciones para importarlo.
	:-En la parte de la izquierda inferior.
	:El Explorador de ficheros.
	:-
	:En la derecha
	:-Inspector -Nos mostrara las opciones del nodo selecionado
	:con sus propiedades.
	:-Nodos - Cuando selecionemos un nodo nos mostrara dos sub pestañas.
	:- - Señales - Son los eventos programados "alertas" que daremos a los nodos
	:para que se comuniquen con el resto.
	:- - Grupos - Nos permite agrupar nodos para luego buscarlos mejor
	:pero consume muchos recursos.
	:-Historial - Es la lista de las ultimas modificaciones realizadas.
	:-
	:En la parte inferior.
	:-Salida - con los resultados de las operaciones
	:-Depurador - Recursos consumidos por nuestro juego.
	:-Resultados de la busqueda.
	:-Audio - Los distintos canales de audio buscados.
	:-Animacion - Creacion o edicion de animaciones importadas.
	:-Editor de Shaders - son modulos encargados de efectos especiales
	:o sombreados, se hace niebla fuego humo sombras brillos etc.
	:Se trabajan directamente en la TGrafica lo que los hace muy rapidos.
*RANDOM Numeros aleatorios
	:Podemos obtener un numero aleatorio usando las funciones
	:randif() o randi()
	:randi() para enteros
	:randf() para flotantes.
	:-
	:var MNum = randi() * 10 + 5;
	:Genera un numero entre 5 y 15.
*RPG Controler 3D
	ª10100ª10099ª10098ª10097ª10096ª10095ª10094ª10093ª10092ª10091ª10089ª10101ª10090
	:https://www.youtube.com/watch?v=0T-FMkSru64
	:-
	:Creamos un manejador para un juego con el PJ
	:visto desde lo alto en un mapa 3D.
	:-
	:Creamos un proyecto 3d.
	:Por una parte creamos una escena "mundo"
	:Dentro añadimos "Nodo3D" "mapa"
	:y Dentro del MAPA añadimos un CSGBox3D para
	:usarlo como base.
	:Creamos el primero para el suelo de 10x10x1m
	:Creamos una carpeta para los materiales.
	:En la carpeta añadimos un resource "StandarMaterial3D"
	:editamos el material y añadimos a "ALBEDO" una textura
	:para el suelo oscuro "Floor_Mat3D".
	:En UV1 lo activamos el Triplano.
	:Luego arrastramos el MATERIAL al OBJETO box3D
	:-
	:Ahora duplicamos el suelo con CTRL+D y le modificamos
	:el tamaño para hacer una pared 1x3x10
	:Y creamos un cuarto con 4 paredes.
	:-
	:Duplicamos el material y creamos "Wall_Mat3D"
	:Le damos la textura naranja a ALBEDO
	:Y aplicamos a los objetos de las paredes por separado.
	:-
	:Ahora creamos colisiones para suelo y paredes.
	:Selecionamos suelo y paredes y en sus propiedades
	:Activamos las colisiones.
	:-
	:Creamos una carpeta para las escenas. "SCN" y guardamos
	:esta escena de MUNDO en esa carpeta.
	:-
	:Añadimos una escena de tipo no definido "cuarta opcion"
	:y selecionamos el nodo tipo "CharacterBody3D"
	:Esto nos crea una escena donde el padre es este
	:tipo de control.
	:Nos da error por que faltaria un "CollisionShape2D"
	:lo añadimos y le decimos que tenga forma de cilindro.
	:Lo colocamos para que quede en el suelo.
	:-
	:Añadimos un nodo3d que contendra al modelo, sera
	:nuestro "PlayerControler", arraspramos el modelo y lo
	:colocamos si fuese necesario.
	:Los objetos con animaciones que estan importados.
	:tienen propiedades ocultas que tenemos que hacer locales
	:para poder modificarlas.
	:Para ello en el "Player" importado presionamos boton derecho
	:y selecionamos "Make Local" para crear una copia local de trabajo.
	:Como podemos ver es un maniky de mixamo con
	:su armature su skeleton su mesh y sus animaciones.
	:-
	:Ahora creamos en el raiz un script con el template de
	:PlayerControler para que nos añada codigo base.
	:-
	:Añadimos en Project/Project Settings las acciones para
	:Front/Back/Left/right y sus teclas asignadas.
	:Modificamos las UI_s que vienen por defecto por las
	:que hemos creado .
	:-
	:Lo primero que haremos es que el PJ se desplaze.
	:Godot da en la plantilla lo necesario pero lo explico.
	:-
	:#-Obtenemos el vector segun las teclas pulsadas
	:var M_Input_V3d = Input.get_vector("ACT_LEFT","ACT_RIGHT","ACT_FRONT","ACT_BACK");
	:#-Eliminamos el eje Y y colocamos mi Y en Z
	:var M_Dir_V3d=Vector3(M_Input_V3d.x, 0, M_Input_V3d.y);
	:#- Transformamos mi vextor segun sus matrizes de transformacion.
	:# si tenemos (a1,a2,a3) (b1,b2,b3),(c1,c2,c3)
	:# y el vector (x,y,z)
	:# resultaria un Vector 3d X=(a1*x+a2*y+a3*z) Y=(b1*x+b2*y+b3*z) Z=(c1*x+c2*y+c3*z)
	:var M_DirTrans_V3d=(transform.basis * M_Dir_V3d);
	:#-la normalizacion divide X,Y,Z por la magnitud total Raiz2(X*X+Y*Y+Z*Z)
	:#- al dividir X,Y,Z por esa constante obtenemos la direcion simple.
	:var M_DirTransNorm_V3d = M_DirTrans_V3d.normalized();
	:#- tambien necesitamos la posicion del keko ya que
	:# los calculos anteriores son respecto al eje del mundo
	:# y se invertirian al pasar de la posicion 0
	:var M_Position_V3d = position;
	:-
	:Ahora quemos que el personaje guire cuando ande
	:hacia donde miramos.
	:La direcion la da el vector de mi teclado pero teniendo en cuenta
	:el eje del mundo , miteclado da +1 o 0 que al colocarse en x-100
	:daria negativo al mirar por eso le sumamos mi posicion.
	:V_PlayerControler.look_at(M_Dir_V3d+M_Position_V3d);
	:-
	:Ahora le indicamos que detecte cuando se comienza a andar
	:y se comienza a parar usando una variable.
	:Cuando comienze a andar o a pararse le decimos que
	:reproducza una animacion en bucle ,una para andar y otra para
	:reposo. Dentro del if , para que lo haga solo una vez .
	:if(!V_IsWalking):
	:_ V_IsWalking=true;
	:_ V_anim_player.play("walk");
	:-
	:Ajustamos la velocidad de movimiento par que encaje con
	:la animacion y el desplazamiento ajustando la variable SPEED
	:const SPEED = 1.6
	:-
	:Ahora para que la animacion no pase de andar a reposo tan
	:secamente añadimos un mezclador a estas animaciones.
	:func _ready():
	:_ #- Añadimos a las animaciones de andar y Reposo un periodo de
	:_ # mezcla de 0,2seg.-
	:_ V_anim_player.set_blend_time("walk","idle",0.2);
	:_ V_anim_player.set_blend_time("idle","walk",0.2);
	:#END _Ready
	:-
*SAVE_LOAD Tabla Arrays
	:En este ejemplo tengo un array de 2 dimensiones con cadenas
	:y lo cargo y guardo en un fichero de texto plano separado
	:por : y donde cada linea es un row.
	:_
	:#byDark 231201 Tabla para las resoluciones.
	:#Se carga desde el fichero.
	:var tab_resoluciones=[
	:_ ["640","480"],["800","600"],["1024","768"],
	:_ ["1152","864"],["1280","720"],["1280","768"],
	:_ ["1280","800"],["1280","960"],["1280","1024"],
	:_ ["1600","1200"],["1920","1080"],["2048","1536"],
	:_ ["2560","1440"],["2560","1600"],["3840","2160"],
	:_ ["4096","2160"],["5120","2880"],["7680","4320"],
	:_ ["10240","4320"]
	:_ ]
	:#byDark 231127 Si no existe el fichero de resoluciones,creamos uno por defecto.
	:# se llama desde f_resoluciones_fileload;
	:func f_resoluciones_savefile():
	:·tvar m_fname=save_path+"resolutions.conf";
	:·tvar m_q=0;
	:·tDirAccess.remove_absolute(m_fname);
	:·tvar m_f = FileAccess.open(m_fname,FileAccess.WRITE);
	:·twhile (m_q<tab_resoluciones.size()):
	:·t·tm_f.store_line(tab_resoluciones[m_q][0]+":"+tab_resoluciones[m_q][1]);
	:·t·tm_q=m_q+1;
	:·t#m_f.store_var(tab_resoluciones);
	:·tm_f.flush();
	:·tm_f.close();
	:·tm_f = null;
	:·tf_log("Save Res:("+m_fname+")");
	:#END f_resoluciones_savefile
	:-
	:#byDark 231127 Si no existe el fichero de resoluciones,creamos uno por defecto.
	:func f_resoluciones_fileload():
	:·tvar m_fname=save_path+"resolutions.conf";
	:·tif(!FileAccess.file_exists(m_fname)):
	:·t·tf_resoluciones_savefile();
	:·telse:
	:·t·tvar m_f= FileAccess.open(m_fname, FileAccess.READ)
	:·t·tvar m_l;
	:·t·tvar m_cels;
	:·t·ttab_resoluciones.clear();
	:·t·twhile(!m_f.eof_reached()):
	:·t·t·tm_l=m_f.get_line();
	:·t·t·tm_cels=m_l.split(":");
	:·t·t·tif(m_cels.size()==2):
	:·t·t·t·ttab_resoluciones.append(m_cels);
	:·t·t#END While
	:·t·tm_f.close();
	:·t·tm_f=null;
	:·t#END if Else Save o Read
	:·tprint("load res:",m_fname);
	:·tprint("load res:",tab_resoluciones);
	:#END f_resoluciones_fileload
*SHADERS
	ª10120
	:https://www.youtube.com/watch?v=kgGhJujTHM8&list=PLMiJk3nm2SG_p968uOTiOEPHXcdT9CPaP
	:Son pequeños programas que se ejecutan en la GPU.
	:Tenemos 3 Tipos de SHADERS
	:-shader_type particles;
	:-shader_type canvas_item;
	:-shader_type spatial;
	:Tenemos tres tipos de procesado
	:-void vertex() {}
	:-void fragment() {}
	:-void light() {}
	:Toman como referencia datos de la imagen procesada y
	:la reprocesan, permitiendo por ejemplo:
	:Pasar una imagen a blanco y negro.
	:Aplicar trasparencia y opacidad a zonas de la imagen.
	:Añadir grano o partes negras a una imagen.
	:Poner solo en gris los colores que no sean rojos.
	:Estos programas estan creados en C++ y toman como
	:base los colores , coordenadas, el tiempo y otros parametros
	:para modificar los colores de los pixels de salida final.
	:RENDER -> ESCALADO -> SHADERS -> IMAGEN
	:Pensemos en un cubo donde su X su Y y su Z se usan
	:como colores Y=Geen X=Blue  y Z=Red de modo que
	:tenemos un cubo de los colores del arcoiris.
	:Un Vector3 o un Vector4 si tomamos el alpha
	:La posicion 0,0,0 seria el negro.
	:Los colores serian hasta 225 y se alejan del centro.
	:Y hacia arriba, X hacia la izquierda y Z hacia el frente.
	:-
	:Los sombreadores o shaders son para posprocesar las
	:imagenes finales antes de la representacion.
	:En godot se crean por medio de un nuevo material tipo SHADER
	:y se aplican a nivel de SUBVIEWPORTCONTAINER ya que son
	:una capa de modificacion de render.
	:Los SHADERS se ejecutan en la Tarjeta Grafica y son calculos
	:matematicos que modificar los colores de la salida a la pantalla.
	*00-Mezcla de colores
		ª10120
		:Una vez creado el material tipo shader le damos un nombre
		:y en la parte central inferior nos aparecera el editor
		:del codigo para el Shader.
		:-
		:Los shader se programan en una especie de C#
		:Primero definiremos el tipo de shader o a que afecta.
		:-
		://- Tendremos dos opciones. "camvas_item" o "particles".
		:shader_type canvas_item;
		://- Creamos 2 constantes Vector3D para dos colores.
		:const vec3 V_ColorA=vec3(0.1,0.1,1.0);
		:const vec3 V_ColorB=vec3(1.0,0.5,0.3);
		:// Called for every vertex the material is visible on.
		:void vertex() {
		:}
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·t//- Creamos un vector3D para un color
		:·tvec3 M_Color= vec3(0.0);
		:·t//- Esto obtienen un float de un arco usando el TIME
		:·t//- y lo pasamos a absoluto positivo.
		:·tfloat M_Pct= abs(sin(TIME));
		:·t//- Mezclamos el color1 con el color 2 en el % anterior.
		:·tM_Color=mix(V_ColorA,V_ColorB,M_Pct);
		:·t//- Definimos el color del Pixel en un Vector4
		:·t//- el 4º valor es el alpha.
		:·tCOLOR=vec4(M_Color,1.0);
		:}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {
		:}
		:-
	*01-Imagen en grises
		ª10122ª10123
		:Ahora despues del render , recorreremos cada pixel
		:Obtenemos su color y su tono para pasarlos a grises.
		:-
		://- Le indico que sera un shader para canvas.
		:shader_type canvas_item;
		://- Genero un vector de color negro.
		:const vec3 V_ColorB=vec3(0.0,0.0,0.0);
		:// Called for every vertex the material is visible on.
		:void vertex() {
		:}
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·t// - Obtengo el color de la textura
		:·tvec3 M_ColorA=texture(TEXTURE,UV).rgb;
		:·t// - Creo un color
		:·tvec3 M_Color=vec3(0.0);
		:·t// - obtengo un % (un arco)
		:·tfloat M_Pc=abs(sin(TIME));
		:·t//- Mezclo el color del pixel objenido con mi color base.
		:·tM_Color=mix(M_ColorA,V_ColorB,M_Pc);
		:·t//-modifico el color del pixel analizado.
		:·tCOLOR=vec4(M_Color,1.0);
		:}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {
		:}
		:-
	*02-Brillo y Saturacion
		ª10123ª10124ª10125
		:El brillo de un color es la interpolacion entre
		:el color negro (0,0,0) hasta el color actual.
		:El contraste es la interpolacion entre el centro de
		:los colores hasta el color actual.
		:La Saturacion es la intepolacion entre el gris del
		:color hasta el color.
		://-Tipo de Shader
		:shader_type canvas_item;
		://- Publica variables
		:// para permitir su modificacion fuera
		:uniform float V_Brillo=0.1;
		:uniform float V_Contrate=0.1;
		:uniform float V_Saturacion=0.1;
		:void fragment() {
		:·t//- Obtengo el color de TEXTURE de la cord UV y bias 0.0
		:·tvec3 M_Color=texture(TEXTURE,UV,0.0).rgb;
		:·t//- Obtengo la interpolacion entre negro
		:·t// y COLOR en V_Brillo%
		:·tM_Color.rgb=mix(vec3(0.0),M_Color.rgb,V_Brillo);
		:·t//- Obtengo la interpolacion entre el medio de los colores
		:·t// y COLOR en V_Contraste%
		:·tM_Color.rgb=mix(vec3(0.5),M_Color.rgb,V_Contrate);
		:·t
		:·t//- Paso mi color a escala de grises
		:·tfloat M_Gris=((M_Color.r+M_Color.g+M_Color.b)/3.0);
		:·t//- Ahora interpolo entre el color gris y
		:·t// mi color en Saturacion%
		:·tM_Color.rgb=mix(vec3(M_Gris),M_Color.rgb,V_Saturacion);
		:·t
		:·t//-Modifico el color del pixel
		:·tCOLOR.rgb=M_Color;
		:}
	*03-Blanco y Negro
		ª10121
		:En este Shader pasaremos una imagen a blanco y negro.
		:Creamos un nuevo shader de tipo CANVAS_ITEM
		:y lo llamamos BlancoNegro
		:-
		:shader_type canvas_item;
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·t//Obtenemos el color del pixel.
		:·tvec3 M_Clr=texture(TEXTURE,UV).rgb;
		:·t// Pasamos el color a tonos de grises.
		:·tfloat M_BW=((M_Clr.r + M_Clr.g +M_Clr.b)/3.0);
		:·t// Pasamos el gris a 0 o a 1 si esta por encima o debajo de 0.4
		:·tM_BW=step(0.4,M_BW);
		:·t// Modificamos el color de salida del pixel
		:·tCOLOR.rgb=vec3(M_BW);
		:}
		:// Called for every vertex the material is visible on.
		:void vertex() {
		:}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {
		:}
	*04-Color Inverso
		ª10126
		:La historia consiste en restar a mi vector de color el
		:color blanco. el Negro es (0.0,0.0,0.0) el blanco es (1.0,1.0,1.0)
		:-
		:shader_type canvas_item;
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·t// Obtengo el color del pixel
		:·tvec3 M_Clr=texture(TEXTURE,UV).rgb;
		:·t//el color esta entre 0.0 Negro y 1.0 Blanco al restar
		:·t//a mi color el blanco Obtengo la inversion de la gama.
		:·tM_Clr=vec3(1.0)-M_Clr.rgb;
		:·t//Modifico el color de salida.
		:·tCOLOR.rgb=M_Clr;
		:}
		:// Called for every vertex the material is visible on.
		:void vertex() {
		:·t
		:}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {
		:·t
		:}
	*05-Marcar Bordes
		ª10128
		:En este caso analizamos los colores contiguos
		:y si su hipotenusa3D es menor que el valor
		:que damos marcara en blanco o negro ese pixel.
		:Esto quema el color negro o blanco segun queramos.
		:-
		:// Shader tipo Canvas
		:shader_type canvas_item;
		:// Distancia de busqueda de pixels.
		:uniform float V_Distancia=0.7;
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·t//Obtengo el color del pixel
		:·tvec3 M_Clr = texture(TEXTURE,UV).rgb;
		:·t//Obtengo el color del pixel X+1
		:·tvec3 M_ClrR = texture(TEXTURE,UV+vec2(1,0)).rgb;
		:·t//Obtengo el color del pixel Y-1 (Abajo)
		:·tvec3 M_ClrD = texture(TEXTURE,UV-vec2(0,1)).rgb;
		:·t// Obtengo la hipotenusa en 3D desde 0,0,0 hasta Color Right.
		:·tfloat M_DistR=length(M_ClrR-M_Clr);
		:·t// Obtengo la hipotenusa en 3D desde 0,0,0 hasta Color Down.
		:·tfloat M_DistD=length(M_ClrD-M_Clr);
		:·t//Si la hipotenusa3D es mayor de VDistancia pongo blanco
		:·t// Si no pongo negro.
		:·tif(M_DistD >V_Distancia || M_DistR>V_Distancia){
		:·t·tCOLOR.rgb=M_Clr+vec3(1,1,1);
		:·t}else{
		:·t·tCOLOR.rgb=M_Clr-vec3(0,0,0);
		:·t}
		:·t
		:}
		:// Called for every vertex the material is visible on.
		:void vertex() {}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {}
	*06-Marcar Bordes con Matriz de Convolucion
		ª10127ª10129ª10130ª10131
		:Esta es la forma correcta de marcar los bordes usando
		:una matriz para saber los colores de todo lo que
		:rodea al pixel central incluido el propio pixel.
		:Segun el tamaño de la matriz y los calculos realizado
		:sobre cada valor de la tabla podemos obtener distintos
		:efectos.
		:Podemos ver una lisa en la wikipedia buscando
		:Kernel Image processing.
		:https://en.wikipedia.org/wiki/Kernel_(image_processing)
		:Tambien tenemos mas ejemplos en
		:https://docs.godotengine.org/en/stable/tutorials/shaders/custom_postprocessing.html
		:Tenemos que tener en cuenta que muchos claculos
		:ya estan incorporados en las gpus por lo que no
		:tendremos que implementarlos.
		:-
		:shader_type canvas_item;
		:// Called for every pixel the material is visible on.
		:void fragment() {
		:·tfloat M_x=SCREEN_PIXEL_SIZE.x;
		:·tfloat M_y=SCREEN_PIXEL_SIZE.y;
		:·t
		:·tvec3 M_Crl1 =-8.0*texture(TEXTURE,UV).xyz ;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(0.0, M_y)).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(0.0, -M_y)).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(M_x, 0.0)).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(-M_x,0.0)).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + SCREEN_PIXEL_SIZE.xy).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV - SCREEN_PIXEL_SIZE.xy).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(-M_x,M_y)).xyz;
		:·tM_Crl1 += texture(TEXTURE, UV + vec2(M_x,-M_y)).xyz;
		:·tCOLOR.xyz = M_Crl1;
		:}
		:// Called for every vertex the material is visible on.
		:void vertex() {}
		:// Called for every pixel for every light affecting the CanvasItem.
		:void light() {}
		:-
		:Este es el ejemplo de la wikipedia para todos los filtros.
		:-
		:// author : csblo
		:// Work made just by consulting :
		:// https://en.wikipedia.org/wiki/Kernel_(image_processing)
		:// Define kernels
		:#define identity mat3(0, 0, 0, 0, 1, 0, 0, 0, 0)
		:#define edge0 mat3(1, 0, -1, 0, 0, 0, -1, 0, 1)
		:#define edge1 mat3(0, 1, 0, 1, -4, 1, 0, 1, 0)
		:#define edge2 mat3(-1, -1, -1, -1, 8, -1, -1, -1, -1)
		:#define sharpen mat3(0, -1, 0, -1, 5, -1, 0, -1, 0)
		:#define box_blur mat3(1, 1, 1, 1, 1, 1, 1, 1, 1) * 0.1111
		:#define gaussian_blur mat3(1, 2, 1, 2, 4, 2, 1, 2, 1) * 0.0625
		:#define emboss mat3(-2, -1, 0, -1, 1, 1, 0, 1, 2)
		:// Find coordinate of matrix element from index
		:vec2 kpos(int index)
		:{
		:return vec2[9] (
		:vec2(-1, -1), vec2(0, -1), vec2(1, -1),
		:vec2(-1, 0), vec2(0, 0), vec2(1, 0),
		:vec2(-1, 1), vec2(0, 1), vec2(1, 1)
		:)[index] / iResolution.xy;
		:}
		:// Extract region of dimension 3x3 from sampler centered in uv
		:// sampler : texture sampler
		:// uv : current coordinates on sampler
		:// return : an array of mat3, each index corresponding with a color channel
		:mat3[3] region3x3(sampler2D sampler, vec2 uv)
		:{
		:// Create each pixels for region
		:vec4[9] region;
		:for (int i = 0; i < 9; i++)
		:region[i] = texture(sampler, uv + kpos(i));
		:// Create 3x3 region with 3 color channels (red, green, blue)
		:mat3[3] mRegion;
		:for (int i = 0; i < 3; i++)
		:mRegion[i] = mat3(
		:·tregion[0][i], region[1][i], region[2][i],
		:·tregion[3][i], region[4][i], region[5][i],
		:·tregion[6][i], region[7][i], region[8][i]
		:·t);
		:return mRegion;
		:}
		:// Convolve a texture with kernel
		:// kernel : kernel used for convolution
		:// sampler : texture sampler
		:// uv : current coordinates on sampler
		:vec3 convolution(mat3 kernel, sampler2D sampler, vec2 uv)
		:{
		:vec3 fragment;
		:// Extract a 3x3 region centered in uv
		:mat3[3] region = region3x3(sampler, uv);
		:// for each color channel of region
		:for (int i = 0; i < 3; i++)
		:{
		:// get region channel
		:mat3 rc = region[i];
		:// component wise multiplication of kernel by region channel
		:mat3 c = matrixCompMult(kernel, rc);
		:// add each component of matrix
		:float r = c[0][0] + c[1][0] + c[2][0]
		:+ c[0][1] + c[1][1] + c[2][1]
		:+ c[0][2] + c[1][2] + c[2][2];
		:// for fragment at channel i, set result
		:fragment[i] = r;
		:}
		:return fragment;
		:}
		:void mainImage( out vec4 fragColor, in vec2 fragCoord )
		:{
		:// Normalized pixel coordinates (from 0 to 1)
		:vec2 uv = fragCoord/iResolution.xy;
		:// Convolve kernel with texture
		:vec3 col = convolution(emboss, iChannel0, uv);
		:// Output to screen
		:fragColor = vec4(col, 1.0);
		:}
	*07-Blending , Fusion
		ª10132
		:Ahora realizaremos una fusion basica.
		:Existen muchos shader en
		:https://godotshaders.com/shader/2d-waterfall/
		:NT: Las funciones usadas han de estar antes
		:de donde se usan.
		:-
		:shader_type canvas_item;
		:// Creamos la importacion de una imagen y
		:// la pongo en negro por def
		:uniform sampler2D V_Image:hint_default_black;
		:vec4 F_Multiply(vec4 Base,vec4 Blend){
		:·treturn Base * Blend;
		:}
		:·t// Called for every pixel the material is visible on.
		:void fragment() {
		:·tvec4 M_Clr=texture(TEXTURE,UV);
		:·tvec4 M_Clr1=texture(V_Image,vec2(UV.x,UV.y));
		:·tCOLOR=F_Multiply(M_Clr,M_Clr1);
		:}
*SPACE SHOOTER 2D
	:Por tratarse de un juego 2D usaremos el Renderizador
	:de movio o compatibilidad.
	:Crearemos un mata mata de navecitas con :
	:Scrool horizontal paralax.
	*CONFIGURACION
		ª10086ª10084
		:Entramos en la configuracion del proyecto y activamos
		:"Configuraciones Avanzadas".
		:-
		:En Aplicacion definimos
		:un nombre y un icono.
		:-
		:En Ejecutar definismos
		:Una escena principal o la seteamos desde el Sistema de archivos .. es lo mismo.
		:FPS maximos
		:-
		:En pantalla de splash
		:Definiremos si queremos pantalla de inicio o no y cual
		:-
		:En Monitor
		:Definimos un viewport de 272x160
		:Modo ventana Wondowed. (O la que sea)
		:Redimensionable = flaso (Es cutre que se pueda redimensionar.)
		:En Sobreescribir Ancho y Alto lo ponemos en 816x480 para
		:depuracion solo.
		:En Estirar le decimos
		:Modo (ViewPort.) y Ascecto (Keep) Modo de estirar que mantiene
		:las proporciones pero puedes ajusta al alto al ancho o ambos.
		:-
		:Ahora como es un juego PixelArt le quitamos el subizado.
		:Saltamos a Renderizado y en
		:Texturas/Texturas del Lienzo/Filtro de texturas le decimos
		:que Neadest que significa Mas cercano al original.
	*ESTRUCTURA
		:En este caso como es un proyecto simple es simple.
		:Tenemos que tener en cuenta que todo en godot son
		:escenas por lo que tenemos.
		:Escena de Enemigos
		:Escena de Game Over
		:Escena de GUI
		:Escena de LEVEL
		:Escena de Menu
		:Escena de Player
		:Escena de Disparo.
		:-
		:Como puedes ver las escenas de
		:Game over, level, menu
		:son las principales
		:el resto son objetos que se usan dentro de estas escenas.
		:-
		:Tambien necesitaremos un AutoLoad o script golbal
		:para lo que necesitemos para todo el proyecto.
		:-
*STRINGS (Funciones)
	:Operaciones a realizar con cadenas.
	:#Obtiene de TEXTO los caracters entre 0 y 5
	:-TEXTO.substr(0,5)
	:#Obtiene de TEXTO los caracetres desde el 5 hasta el ultimo.
	:-TEXTO.substr(5)
	:#Elimina los caracteres en blando del inicio y del final
	:#del TEXTO
	:-TEXTO.strip_edges()
	:#Separa la cadena en subcadenas usando "," como el
	:#separador.
	:-TEXTO.split(",")
	:#Devuelve TEXTO quitando los espacios al principio,
	:-TEXTO.lstrip()
	:#Devuelve TEXTO quitando los espacios al Final,
	:-TEXTO.rstrip()
	:#Devuelve el Caracter 10 de TEXTO
	:-TEXTO[10]
	:-#Devuelve el numero de caracteres de una cadena.
	:TEXTO.length()
	:# Convertir la cadena a mayúsculas
	:-TXT.to_upper()
	:# Convertir la cadena a minúsculas
	:-TEXT.to_lower()
	:var Mfloat:float=123456.789;
	:var MStr="%07.2f" %Mfloat;
	:print(MStr);#123456.79
	:print("%07.2f"%Mfloat);#123456.79
	:var MStr1="%020.2f" %Mfloat;
	:print(MStr1);#00000000000123456.79
	:var MStr2="%20.2f" %Mfloat;
	:print(MStr2);#           123456.79
	:print("%20.2f" %Mfloat);#           123456.79
	:print("%10.2f" %(1234.12));#            1234.12
	:var Mf1 = roundf(3.78);
	:print(Mf1);#4
*Third Person Controller
	:https://www.youtube.com/watch?v=EP5AYllgHy8
	:Controlador de personaje para tercera persona.
	:Camara en el hombro.
	:Andar
	:Correr
	:Patada.
	:Rotar camara
*TIEMPOS
	:En godot podemos obtener temporizadores y las fechas y horas
	:con distintas funciones:
	:-
	:Time.get_ticks_msec();
	:#Obtiene en milisegundos el tiempo transcurrido desde que
	:se ejecuto el juego.
	:-
	:Time.get_unix_time();
	:#Devuelve el tiempo en segundos desde la época (por lo general, el 1 de enero de 1970).
	:-
	:Time.get_real_time();
	:Devuelve el tiempo en segundos desde que se inició el sistema operativo, con alta precisión.
	:-
	:Time.time_passed();
	:Propiedad que devuelve el tiempo transcurrido desde el último cuadro en segundos.
	:-
	:Time.delta();
	:Propiedad que devuelve el tiempo transcurrido desde el último cuadro en segundos, ajustado por la escala del tiempo.
	:-
	:delta;
	:en _process(delta): En el método _process(delta), delta representa el tiempo transcurrido desde el último cuadro en segundos.
	:-
	:Tambien tenemos los "Timer" que son contadores de tiempo
	:que cada X disparan una señal o evento.
	:-
	:Por control.
	:Creamos un nodo "TIMER" y lo configuramos y por codigo
	:le decimos cuando comienza y para y en el control le decimos
	:que funcion dispara con un evento.
	:-
	:# Esta función se ejecutará cuando el temporizador
	:alcance el tiempo de espera
	:func _on_Timer_timeout():
	:_ print("¡El temporizador ha alcanzado el tiempo de espera!")
	:func _process(delta):
	:_ # Puedes iniciar el temporizador cuando sea necesario, por ejemplo, al presionar una tecla
	:_ if Input.is_action_just_pressed("start_timer"): $Timer.start();
	:_ # También puedes detener el temporizador si es necesario, por ejemplo, al presionar otra tecla
	:_ if Input.is_action_just_pressed("stop_timer"): $Timer.stop();
	:-
	:Tambien podemos crear el contron "TIMER" por codigo.
	:-
	:func _ready():
	:_ # Crea un nuevo nodo Timer
	:_ var timer = Timer.new()
	:_ # Configura el tiempo de espera en segundos
	:_ timer.wait_time = 2.0
	:_ # Conecta la señal timeout a una función
	:_ timer.connect("timeout", self, "_on_CustomTimer_timeout")
	:_ # Agrega el nodo Timer como hijo de este nodo
	:_ add_child(timer)
	:_ # Inicia el temporizador
	:_ timer.start()
	:func _on_CustomTimer_timeout():
	:_ print("¡El temporizador ha alcanzado el tiempo")
	:-
	:Tambien podemos acceder al relog del sistema por medio
	:del la clase "DateTime.Now".
	:-
	:var now = DateTime.now();# Obtiene la fecha y hora actual
	:var year = now.get_year();# Año
	:var month = now.get_month();#Mes 1-12
	:var day = now.get_day();# Dia 1-31
	:var hour = now.get_hour();# Hora 0-23
	:var minute = now.get_minute();# Minutos 0-59
	:var second = now.get_second();# Segundos 0-59
	:var millisecond = now.get_millisecond();# Milisegundos
	:-
	:Si necesitamos la hora en formato 12h podemos usar
	:-
	:var now = DateTime.now()
	:var hour = now.get_hour()
	:var am_pm = "AM"
	:# Ajusta la hora al formato de 12 horas y determina si es AM o PM
	:if hour > 12:
	:_ hour = hour % 12
	:_ am_pm = "PM"
	:# Asegura que la medianoche (00:00) se muestre como 12:00 AM
	:if hour == 0:
	:_ hour = 12
	:print("Hora: ", hour)
	:print("AM/PM: ", am_pm)
*TILEMAP
	ª10040ª10041ª10042ª10044ª10060
	:Se trata de un modulo para pintar una cuadricula.
	:El propio control se encarga de colisiones, mapa
	:de navegacion y mucho mas.
	:Primero añadimos el control TileMap a una escena.
	:En el TileMap creamos un TileSet que es la configuracion
	:del TILEMAP, podemos guardar este SET para usarlo en
	:otras partes del juego.
	:Al lado del Tile Set aparecera un cuadro azul que si le
	:pinchamos podemos acceder a la configuracion de ese
	:SET del TILEMAP.
	:-
	:TileSet (Configuramos los suelos)
	:En el centro inferior selecionamos el TileSet y arrastramos
	:el Mapa.png con los suelos u objetos usados para dibujar
	:el mundo.
	:Nos mostrara un mensaje de si queremos que auto ajuste
	:cada mapa o si queremos hacerlo nosotros.
	:Si lo hacemos nosotros tendremos que dibujar los bordes
	:de cada placa de suelo, pared o lo que sea.
	:Definiremos nombre,Margenes,Separacion,Tamaño de
	:cuadricula etc.
	:Y pikaremos para decirle que partes de la imagen son
	:los suelos...
	:-
	:TileMap (Dibujamos los suelos.)
	:En la parte inferior centrar tenemos el propio TileMap
	:que nos mostrara los distintos TILES para poder dibujar el
	:mundo segun los que tengamos configurados.
	:-
	:Por defecto viene configurado para cuadros de 16x16 pero
	:si queremos otro tamaño tenemos que definirlo en las
	:propiedade del TileMAP y en el TileSet y del Tile.
	*AUTO TILE MAP
		ª10052ª10053ª10054ª10055ª10056ª10057ª10058
		:AUTO TILEMAP
		:Esta es una herramienta para que el TileMap Autopinte
		:terrenos.
		:Otra vez en el TileSet definimos un nuevo TerrainSets.
		:Definimos el modo de calculo que usara para ajustar
		:los suelos (Esquinas , Suelos o los dos.)
		:Y añadimos un Suelo, Le damos un color y un nombre
		:descrictivo.
		:NT: Dentro del TERRAIN SET podemos crear distintos
		:elementos para cada tipo de suelo que tengamos en el
		:TILE (Atlas de suelos y paredes.)
		:NT: Tambien podemos Añadir distintos TERRAIN SET
		:para que ajuste de otro modo el suelo. osea. tenemos
		:uno para que ajuste por esquinas y otro por suelos
		:Y el de esquinas solo tiene 1 tipo de mapa (serva)
		:Y el de Suelos Tenemos 3 Ladrillo, Pantano, cienaga.
		:-
		:Ahora en el PAINT del TileSet en PROPERTIES elegimos
		:TERRAIN selecionamos el TERRAIN Set (Tipo de ajuste)
		:y dentro el TERRAIN (tipo de suelo).
		:Y en cada Sprite pintamos dejando el suelo o las
		:es quinas sin pintar. (Es muy util)
		:-
		:Despues en el TILEMAP en la seccion superior
		:TERRAINS selecionamos el
		:TERRAIN SET (Tipo de ajuste) y el
		:SUB TERRAIN (Tipo de suelo) y pintamos. El
		:propio motor colocara pared esquina o interior segun lo
		:crea combeniente.
	*COLLISION LAYERS
		ª10043ª10044ª10045ª10046ª10047ª10048
		:COLISIONES
		:Tambien podemos definir colisiones en los Tiles que
		:queramos, para ello tenemos que definir sus fisicas.
		:En las propiedades del TileMap cuando creamos un TileSet
		:Delante aparece icono con cuadros azules. si le pikamos
		:nos muestra el TileSize para modifica el tamo de los Tiles y
		:ajustar el grill y debajo.
		:Phisics Layers, pinchamos en ADD Element y asi creamos un
		:mapa de colisiones, le decimos el LAYER.
		:Ahora en el TileSet.
		:Tenemos que pintar las colisiones.
		:En PAINT selecionamos el Phisical Layer que hemos creado
		:y nos mostrara un recuadro donde al pinchar en cada uno de
		:los Tiles nos lo mostrara y de forma vectorial le damos el
		:poligono de colision.
		:Por defecto pone 4 vertices pero podemos añadir mas si
		:lo necesitamos.
	*NAVIGATION LAYERS
		ª10050ª10051ª10048
		:CAPAS DE NAVEGACION
		:Al igual que las colision Map, si queremos que un enemigo
		:sepa por donde moverse le podemos indicar ese espacio.
		:En el TileMap.TileSET. buscamos "Navigation Layer"
		:y creamos un MavigationLayer
		:Definimos el Layer.
		:Ahora en la configuracion del TileSet PAINT y en
		:Paint Properties , selecionamos que editaremos el
		:Navigation Layer, y el resto es lo mismo.
	*TILESET y CAPAS
		ª10044ª10043
		:TILESET
		:(Configuramos los suelos)
		:En el centro inferior selecionamos el TileSet y arrastramos
		:el Mapa.png con los suelos u objetos usados para dibujar
		:el mundo.
		:Nos mostrara un mensaje de si queremos que auto ajuste
		:cada mapa o si queremos hacerlo nosotros.
		:Si lo hacemos nosotros tendremos que dibujar los bordes
		:de cada placa de suelo, pared o lo que sea.
		:Definiremos nombre,Margenes,Separacion,Tamaño de
		:cuadricula etc.
		:Y pikaremos para decirle que partes de la imagen son
		:los suelos...
		:-
		:TileMap (Dibujamos los suelos.)
		:En la parte inferior centrar tenemos el propio TileMap
		:que nos mostrara los distintos TILES para poder dibujar el
		:mundo segun los que tengamos configurados.
		:-
		:Por defecto viene configurado para cuadros de 16x16 pero
		:si queremos otro tamaño tenemos que definirlo en las
		:propiedade del TileMAP y en el TileSet y del Tile.
		:Podemos tener distintos SET para los TITLE y podemos
		:configurarlos por medio del boton azul 1que aparece
		:al lado del TILE SET.
		:-
		:CAPAS
		:Tambien podemos crear distinas capas para distintos niveles
		:siendo las capas mas proximas las que tengan un ZIndex
		:mas alto. (0 = fondo 1= Frente 2 MasFrente etc)
		:Para ello buscamos la seccion LAYERS en el TileMap.
		:Y crearemos tantas capas como profundidad querramos que
		:tenga el mapa.
		:Luego para dibujar el mapa solo tenemos que selecionar la
		:capa a modificar en el comobo derecho..
		:-
*TRADUCIONES
	:Para añadir traduciones a nuestros juegos usaremos ficheros con
	:una clave y por columna los distintos idiomas.
	:-
	:Ejemplo de Fichero "Trans_UI.csv"
	:-
	:KEYs,es,en
	:UIKEYS_TitWin,"Configuracion de teclado","Config Keys"
	:UIKEYS_PressKey,"Pulse una tecla","Press Key"
	:-
	:El godot usara ES o EN para filtrar la columna con el idioma a usar.
	:La primera columna "KEY" identifica el texto a remplazar no
	:tiene por que ser KEY ya que a godot le da igual el usa la
	:columna 0 para localizar el texto a remplazar con la columna del
	:idioma.
	:NT: Key no es el nombre del control es el TEXTO del control.
	:-
	:Las claves delos idiomas las puedes encontrar en
	:https://docs.godotengine.org/es/4.x/tutorials/i18n/locales.html#doc-locales
	:-
	:Selecionado el fichero .CSV y REIMPORTAMOS
	:definiendo que caracter separa las columnas y
	:si queremos que comprima el texto.
	:Reimportamos el fichero y asi nos generara X
	:ficheros segun el numero de idiomas.
	:-
	:Trans_UI.EN.translation
	:Trans_UI.ES.translation
	:-
	:Una vez realizado esto 1 vez y si la estructura es correcta
	:en cuanto modifiquemos algo en el CSV reimportara de
	:forma automatica.
	:-
	:Por ultimo tendremos que añadir en
	:Project Setings/Localization / Translations
	:los ficheros .translation
	:-
	:Tambien podemos añadir distintos recursos para los
	:idiomas del mismo tipo pero añadiendolas en
	:Project Setings/Localization / Rempas
	:Esto permitiria añadir anuncios o audios segun el pais.
	:-
	:Las traduciones son a tiempo real de modo que en cuanto
	:modifiquemos el texto de un control godot lo buscara y traducira
	:al idioma indicado.
	:Esto lo podemos bloquear por medio de las propiedades LOCALIZATION
	:de cada control.
	:-
	:Tambien podemos traducir algo a mano usando la funcion TR()
	:level.text = tr("LEVEL_5_NAME")
	:-
	:Podemos definir el idioma que usara por medio de.
	:TranslationServer.set_locale("EN");
	:El codigo de idioma esta definido por godot.
	:-
	:Las traduciones se hacen por medio de
	:la clase TranslationServer
	:-
	:TranslationServer <- Object
	:- PROPIEDADES
	:bool·tpseudolocalization_enabled [default: false]
	:- METODOS
	:void·t·tadd_translation(translation: Translation)
	:void·t·tclear()intcompare_locales(locale_a: String, locale_b: String) const
	:PackedString·tArrayget_all_countries() const
	:PackedString·tArrayget_all_languages() const
	:PackedString·tArrayget_all_scripts() const
	:String·t·tget_country_name(country: String) const
	:String·t·tget_language_name(language: String) const
	:PackedString·tArrayget_loaded_locales() const
	:String·t·tget_locale() constStringget_locale_name(locale: String) const
	:String·t·tget_script_name(script: String) const
	:String·t·tget_tool_locale()Translationget_translation_object(locale: String)
	:String·t·tNamepseudolocalize(message: StringName) const
	:void·t·treload_pseudolocalization()
	:void·t·tremove_translation(translation: Translation)
	:void·t·tset_locale(locale: String)
	:String·t·tstandardize_locale(locale: String) const
	:String·t·tNametranslate(message: StringName, context: StringName = "") const
	:String·t·tNametranslate_plural(message: StringName, plural_message: StringName, n: int, context: StringName = "") const
	:-
	:Tambien usara la clase TRANSLATION
	:-
	:Translation < Resource < RefCounted < Object
	:- - PROPIEDADES
	:Stringlocale [default: "en"]
	:- - METODOS
	:String·t·tName_get_message(src_message: StringName, context: StringName) virtual const
	:String·t·tName_get_plural_message(src_message: StringName, src_plural_message: StringName, n: int, context: StringName) virtual const
	:void·t·tadd_message(src_message: StringName, xlated_message: StringName, context: StringName = "")
	:void·t·tadd_plural_message(src_message: StringName, xlated_messages: PackedStringArray, context: StringName = "")
	:void·t·terase_message(src_message: StringName, context: StringName = "")
	:String·t·tNameget_message(src_message: StringName, context: StringName = "") const
	:int·t·tget_message_count() const
	:PackedString·tArrayget_message_list() const
	:String·t·tNameget_plural_message(src_message: StringName, src_plural_message: StringName, n: int, context: StringName = "") const
	:PackedString·tArrayget_translated_message_list() const
*TWEEN
	ª10034
	:TWEEN es como se llama el proceso por el cual
	:una animacion pasa del FTG-A al FTG-B.
	:Tambien sele conoce como interpolacion.
	:-
	:Tenemos 3 propiedades principales.
	:-Tween_property para intercalar propiedades como posicon
	:escala, color etc.
	:-Tween_Method para intercalar funciones.
	:-Tween_callback , señal emitida cuando termina una
	:operacion tween.
	:-
	:Lo primero que hacemos es crear un objeto Tween.
	:Este objeto se encuentra en el nodo padre por lo que si
	:el script esta en el nodo padre lo crearemos con
	:self.create_tween
	:y si esta en un sub nodo usaremos
	:get_tree.create_tween
	:Tambien podemos parar un Tween con Tween.stop().
	:-
	:Luego podemos definir el tipo de transacion, tiempo,
	:curva de final, como reaciona ante la pausa y mucho mas.
	:-
	:Despues tenemos dos opciones.
	:Le indicamos objeto y propiedad a transacionar o
	:Le indicamos una funcion que recivira el float de la transacion.
	:Set_delay(val) retiene el inicio de una animacion X segundos.
	:-
	:extends Node2D
	:func _ready():
	:_ var V_Tween:Tween=self.create_tween();
	:_ V_Tween.set_loops(2);#Numero de repeticiones
	:_ V_Tween.set_parallel(true);#Indica para todo o se ejecuta paralelamente al resto.
	:_ V_Tween.set_trans(Tween.TRANS_QUAD);
	:_ V_Tween.set_ease(Tween.EASE_IN_OUT);#Tipo de final de la transacion.
	:_ V_Tween.set_pause_mode(Tween.TWEEN_PAUSE_STOP);# Tipo de pausa al pausar la animacion.
	:_ V_Tween.set_speed_scale(20);#Multiplicador de tiempo.
	:_ V_Tween.tween_property($Label,"rotation",360,1000).set_delay(50);
	:_ V_Tween.tween_property($Label,"scale",Vector2(200,200),1000);
	:_ V_Tween.tween_property($Label,"position",Vector2(1000,500),50);
	:_ V_Tween.tween_method(F_TweenStep,1,500,400);
	:_ V_Tween.tween_callback(F_TweenEnd);
	:#END _ready
	:func F_TweenEnd():
	:_ print("Tween Termino.");
	:#END F_TweenEnd():
	:func F_TweenStep(PASO:int):
	:_ print(str(PASO));
	:#END F_TweenStep():
	:func _process(delta):
	:_ pass
*V4 Controlador Basico 3D
	:https://www.youtube.com/watch?v=J5-0X9xPDVE
	:- Controlador sencillo para personajes 3D
*VARIABLES y CONSTANTES
	:Godot es fuertemente tipado.
	:Una variable de un tipo solo acepta ese tipo.
	:Godot es caseSensitive. (Diferencia entre mayusculas y minusculas.)
	:Godot acepta subrallados.
	:-
	:Las variables (var NOM : TIPO = VAL)
	:Se encargan de almacenar y tratar datos.
	:Se pueden modificar sus datos
	:No pueden almacenar tipos de datos distintos.
	:-
	:Las constantes.(const NOM : TIPO = VALOR)
	:Se encargan de almacentar y tratar datos.
	:No se pueden modifiar sus datos.
	:No es necesario definir si tipo.(Lo ajusta de forma automatica.)
	:-
	:Las variables y constantes tienen alcance local.
	:Las variables dentro de una funcion solo alcanzan esa funcion
	:Las variables dentro de una clases solo dentro de la clase
	:-
	:Para permitir que una variable sea accesible desde fuera.
	:se usa el comando "@export".(@export var NOM : TIPO)
	:Existen muchos tipos de @exports segun el dato que queramos exportar.
	:EJ: @export_multiline var DESC : string; (Define un string multilinea.)
	:-
	:Para definir variables godot usa el comando "var"
	:-
	:var NomVar : TipoDato=Dato
	:-
	:Varibles
	:-
	:var P_Jugador_Nombre:String="Pako";
	:var p_jugador_Nombre:String="Pako";
	:var P_Jugador_Edad:int=30;
	:var P_Jugador_Velocidad:float=10.99;
	:var P_Jugador_Vivo:bool=true;
	:var P_Array:Array=[1,2,3,"4",5];
	:-
	:Constantes
	:-
	:const C_Jugador_Nombre:String="Pako";
	:const c_jugador_Nombre:String="Pako";
	:const C_Jugador_Edad:int=30;
	:const C_Jugador_Velocidad:float=10.99;
	:const C_Jugador_Vivo:bool=true;
	:const C_Array:Array=[1,2,3,"4",5];
	:-
	:Variables exportables
	:-
	:@export var v_Jugador_Nombre:String="Pako";
	:@export var V_jugador_Nombre:String="Pako";
	:@export var V_Jugador_Edad:int=30;
	:@export var V_Jugador_Velocidad:float=10.99;
	:@export var V_Jugador_Vivo:bool=true;
	:@export var V_Array:Array=[1,2,3,"4",5];
	:-
	:Existen distintos tipos de export segun el tipo de dato
	:que queramos usar.
