{WinHelper V1.05 by FNX A1 2022}
{TITTLE}
{WIN_W}00371
{JPG_SIZE}00060
{IMG_AUTO}10000
{WIN_DESC_H}00492
{WIN_DESC_PIC_H}00068
{WIN_EDT_GRP_H}00185
{WIN_ALING_LEFT}00000
{WIN_IMG_CFG}.0010.0010.0640.0480.0100
{PANLAT_CLR}000,255,000

*PYTON
	·20231102170855
	ª10000ª10001ª10002ª10003
	:https://youtu.be/b4AgSGA39Ds?t=1650
	:Descargamos la version de pyton desde:
	:- https://www.python.org/downloads/
	:Instalamos Pyton y seguimoslas indicaciones
	:Tambien podemos instalarlo de modo avanzado.
	:-,
	:- Habrimos una ventana CMD (en windows)
	:- Para ver que esta todo correcto ejecutamos el comando
	:- py - - version (Doble - sin espacios)
	:- Si todo esta ok nos mostrara Python X.XX.X
	:- py es un comando que ataca al python.exe de la ruta donde lo instalaste.
	:- Si lo instalaste a lo loco es posible que esta ruta no este bien, te lo dira.
	:-
	:- REPL = Read, Evol, Print and Loop
	:- Bucle de lectura, Evaluacion e Impresion.
	:- Asi es como se llama el interprete, cuando
	:- ejecutamos el propio Python.exe se carga un editor
	:- de texto que lee, evalua , ejecuta y repite .
	:- Si queremos SALIR del REPL introducimos el comando CTRL+Z +Intro
	:- el REPL nos permite ejecutar bloques de codigo o
	:- comandos sueltos pero no nos permite crear programas.
	:- Para crear programas necesitamos un IDE
	:-
	:-IDE = Entorno de Desarrollo Integrado.
	:-Este es un programa que nos permite guardar y administrar
	:-los ficheros y generar compilados capturando errores y demas.
	:-
	:-Tenemos muchas opciones e incluso podemos generar los fichero
	:-con el notepad pero los mas usados son:
	:- VSCode con las extensiones Python y Pylance o Pylint
	:-PyCharm creado explicitamente por la comunidad para python (Es de pago)
	:-Visual Studio Code
	:-https://code.visualstudio.com/docs/?dv=winzip
	:-Le añadiremos dos extensiones .
	:- Python y Pylance o Pylint
	:VSC nos permite tener todo a mano en este caso abrimos
	:el terminal que seria como una ventana dos para ejecutar el compilador.
	:Pyton anida con tabs.
	:Pyton es un lenguaje interpretado.
	:Pyton es Freeware
	:Pyton es Open Source
	:Pyton es CaseSensitive
	:Las variables son todas VARIANT
	:las variables son publicas
	:las variables son referidas (paso por referenica)
	:una aplicacion entra por la funcion
	:def main():
	:una clase entra por la funcion
	:__init__(self, nombre);
	:si una aplicacion se usa como clase se tiene que forzar
	:la funcion main usando.
	:if __name__ == "__main__": main();
	:
	*Variables
		·20230927184558
		ª10005
		:Por norma todas las variables son de tipo VARIANT
		:esto significa que no tienen tipo definido,
		:incluso una variable puede tener distintos tipos
		:de datos en su vida.
		:-
		:Por norma se nombras las variables segun el tipo ya que son "VARIANT"
		:Todas las variables son publicas y accesibles para todo el codigo.
		:Las varables creadas dentro de las funciones solo son accesibles dentro.
		:Al pasar una variable a una funcion se crea un clon de
		:la misma excepto si son variables compuestas, listas o clases.
		:-
		:Por norma las variables y funciones privadas dentro
		:de las clases comienzan con un "_" pero es "por norma"
		:-
		:Es posible acceder tambien a dichas variables desde
		:fuera de las funciones.
		:-Yo aconsejo (V_NOMBRE_TIPO)
		:-V=Glovales Para todo el codigo P=Propias Para Funciones.
		:-Str,Int,Dbl,Dec,Lst,Arr,Boo
		:-
		:-Antes de nada crearemos la carpeta para el proyecto.
		:-En VSC abrimos dicha carpeta en "Archivo/Abrir Carpeta" de este
		:modo nos mostrara los ficheros del proyecto.
		:-Es aconsejable crear las variables en un fichero aparte.
		:# Variables y funciones locales
		:variables_locales = list(locals().keys())
		:funciones_locales = [nombre for nombre, valor in locals().items() if callable(valor)]
		:# Variables y funciones globales
		:variables_globales = list(globals().keys())
		:funciones_globales = [nombre for nombre, valor in globals().items() if callable(valor)]
		:# Imprimir las listas
		:print("Variables locales:", variables_locales)
		:print("Funciones locales:", funciones_locales)
		:print("Variables globales:", variables_globales)
		:print("Funciones globales:", funciones_globales)
		:-
		:-
		:# VAR no se modifica dentro son distintas.
		:VAR="hola"
		:def mi_funcion():
		:<tab>VAR = 10
		:<tab>print(VAR)
		:print(VAR)
		:mi_funcion()
		:print(VAR)
		:-
		:#Le paso Variable STR a la funcion pero no se modifica
		:Nombre="Casa";
		:print("EX",Nombre);
		:def F_01(M_Nombre):
		:<tab>print("IN",M_Nombre);
		:<tab>M_Nombre="OCUPADA";
		:<tab>print("IN",M_Nombre);
		:print("PRE",Nombre);
		:F_01(Nombre);
		:print("POS",Nombre);
		:-
		:#Le paso una variable INT a la funcion y no se modifica
		:Numero=20;
		:print("EX",Numero);
		:def F_01(M_Nombre):
		:<tab>print("IN",M_Nombre);
		:<tab>M_Nombre=50;
		:<tab>print("IN",M_Nombre);
		:print("PRE",Numero);
		:F_01(Numero);
		:print("POS",Numero);
		:-
		:#Le pasamos una lista a la funcion y SI la modifica.
		:mi_lista = [1, 2, 3]
		:print(mi_lista)
		:def modificar_lista(lista):
		:<tab>print(lista)
		:<tab>lista.append(4) # Esto modifica la lista original
		:print(mi_lista)
		:modificar_lista(mi_lista)
		:print(mi_lista) # Esto imprimirá [1, 2, 3, 4]
		:-
		:#La funcion retorna 3 valores distintos.
		:resultado1 = "A";resultado2 = "A";resultado3 = "A";
		:def obtener_resultados():
		:<tab>resultado1 = 10
		:<tab>resultado2 = "Hola"
		:<tab>resultado3 = [1, 2, 3]
		:<tab>print("IN",resultado1,resultado2,resultado3) # Esto imprimirá 10
		:<tab>return resultado3, resultado1, resultado2
		:-
		:print("INI",resultado1,resultado2,resultado3); # Esto imprimirá 10,hola,[1,2,3]
		:resultado1, resultado2, resultado3 = obtener_resultados();# Llamamos a la funcion
		:print("OUT",resultado1,resultado2,resultado3); # Esto imprimirá [1,2,3],10,hola
		:#
		:#
		:# Variables y funciones locales
		:V_VarLocKeys_Lst = list(locals().keys())
		:V_VarLocVals_Lst = list(locals().values())
		:funciones_locales = [nombre for nombre, valor in locals().items() if callable(valor)]
		:# Variables y funciones globales
		:variables_globales = list(globals().keys())
		:funciones_globales = [nombre for nombre, valor in globals().items() if callable(valor)]
		:# Imprimir las listas
		:print(" ")
		:print("Variables Locales",len(V_VarLocKeys_Lst));
		:for Mq in range(0,len(V_VarLocKeys_Lst)):
		:print (Mq,V_VarLocKeys_Lst[Mq], V_VarLocVals_Lst[Mq]);
		:print(" ")
		:print("Variables Locales",len(variables_locales));
		:for M_VL in variables_locales:
		:print (M_VL,len(M_VL));
		:print(" ")
		:print("Funciones Locales")
		:for M_FL in funciones_locales:
		:print (M_FL);
		:print(" ")
		:print("Variables Globales")
		:for M_VG in variables_globales:
		:print (M_VG);
		:print(" ")
		:print("Funciones Globales")
		:for M_FG in funciones_globales:
		:print (M_FG);
		:
	*Bucles For
		·20230927184558
		:Nor permite repetir un numero de veces un grupo de sentencias.
		:-
		:#Estructura base del for
		:for Var in (1,2,3)
		:<tab>Sentencia
		:<tab>Sentencia
		:<tab>Sentencia
		:-
		:#Imprimimos un hola para cada nombre de la tabla.
		:V_Nombres_Str=["A","B","C"]
		:for M_Nom in V_Nombres_Str
		:<tab>print("Hola",M_Nom);
		:-
		:#Repetimos Por cada letra de hello (5lops)
		:for character in "hello":
		:<tab>print(character)
		:-
		:#Repetimos de 5 hasta 10 (6lops)
		:for X in range (5,11):
		:<tab>print(X)
		:-
		:#Repetimos de 0 hasta 3 (4lops)
		:for X in range(4):
		:<tab>print(X)
		:-
		:#Repetimos de 10 hasta 1 decontando 1 en cada loop (10lops)
		:for X in range(10,0,-1):
		:<tab>print(X)
		:-
		:#Repetimos de 0 hasta 8 incrementando 2 en cada loop (5lops)
		:for X in range(0,10,2):
		:<tab>print(X)
		:-
		:#Calculamos y mostramos las tablas de multiplicar.
		:V_Num1_Int=0;V_Num2_Int=0;
		:V_Res_Str="";
		:for V_Num1_Int in range(0,11):
		:<t>for V_Num2_Int in range(0,11):
		:<t><t>V_Res_Str+=">"+str(V_Num1_Int)+"*"+str(V_Num2_Int)+"="+str((V_Num1_Int*V_Num2_Int))+" ";
		:<t>print(V_Res_Str);
		:<t>V_Res_Str="";
		:
	*Condicionales
		·20230927184558
		:>= Mayor que
		:<= Menor que
		:== Igual que
		:>= Mayor o igual
		:<= Menor o igul
		:!= Distinto que
		:or = X o Y
		:and = X y Z
		:not = no X ( X and not Y)
		:
		*if elif else
			·20230927184558
			:Evalua una sentencia, ejecutando lo que se encuentra dentro
			:del bloque si la condicion es verdadera.
			:-
			:La condicion puede estar o no entre comillas.
			:Despues de la condicion los : indican que comienza
			:el codigo a ejecutar.
			:-
			:if - evalua una condicion
			:elif - si no son las condiciones anteriores evalua una nueva.
			:else - si no son ninguna de las condiciones anteriores.
			:-
			:Recordar que las instruciones han de estar tabuladas mas alla
			:del nivel del if, elif, else.
			:-
			:if x>0:
			:<tab>print(x)
			:else:
			:<tab>print(-x)
			:- - -
			:if (x>0):
			:<tab>print(x);
			:elif (xz0):
			:<tab>print(x);
			:else:
			:<tab>print(-x);
			:- - -
			:V_Curso_Str=input("Cual es tu curso?")
			:if(V_Curso_Str=="5"):
			:<tab>print ("quinto curso.");
			:elif(V_Curso_Str=="4"):
			:<tab>print("Cuarto curso");
			:
	*Operadores
		·20230927184558
		:+= -Incrementa el valor de la variable en X
		:-= -Decrementa el valor de la variable en X
		:* -Multiplicacion
		:** -Potencia
		:/ -Division
		:// -Division entera
		:% -Modulo (resto de una division)
		:+ = concatena dos variables texto.
		:' = define cadena
		:" = define cadena.
		:# comenta una linea.
		:int('23') =convierte un texto a entero.
		:float('123') = convierte un texto a flotante.
		:round(-1.7) = -2 redondea un numero a su proximo entero.
		:bool(-10) = es falso si es 0 o vacio, el resto es true.
		:len("cad") = tamaño de la cadena pasada =3
		:str(123) = obtiene la cadena de un numero = "123"
		:"CADENA".find("A") = 1 retorna la primera coincidencia si no -1
		:"CADENA".find("A",2) = 5 retorna la siguiente coincidencia desde la pos 2 (si no -1)
		:"CADENA".replace("A","Z") = "CZDENZ" Remplaza una cadena por otra.
		:"CADENA".replace("A","Z",1) = "CZDENA" Remplaza una cadena por otra solo 1 vez
		:"CADENA".count("A") = 2 retorna las veces que a encontrado la cadena.
		:"CADENA"[1] ="A" obtiene la posicion 1 de la cadena (Comienza por la 0)
		:"ABCDE"[-1] ="E" Los valores negativos comienzan desde el final
		:"ABCDE"[1:3] ="BCD" Coje los valors desde la pos 1 hasta la 3.
		:"ABCDE"[1:-1] ="BCD" Coje los valores desde la posicion 1 hasta la penultima
		:"ABCDE"[:2] ="AB" Coje desde el 0 hasta el 2
		:"ABCDE"[2:] ="CDE" Coje desde el 3 hasta el fonal
		:"ABCDE"[::2] ="ACE" Coge cada 2 Chars
		:"ABCDEF"[1::2] ="BDF" Coge cada 2 Chars desde el 1
		:"ABCDEF"[::-1] ="FEDCBA" Invierte la cadena
		:isinstance(Var, Tipo) = bool Revisa si una variable es del tipo dado.
		:
	*Clases
		·20230927184558
		:Las clases con bloques de codigos que agrupan
		:funciones y variables y realizan tareas concretas.
		:Se usa el codigo "class NombreClase" para crearlas
		:class ClaseA
		:<tab>def __init__(self):
		:<tab><tab>self.variable = 10
		:la funcion "def __init__(self)" es la primera funcion
		:que por defecto es llamada al instanciar la clase.
		:Aunque las variables son publicas es mejor usar seters y geters
		:def get_nombre(self):
		:<tab>return self._nombre
		:def set_nombre(self, nuevo_nombre):
		:<tab>self._nombre = nuevo_nombre
		:o mejor usar los decoradores @property y @NOMBRE.setter
		:class Persona:
		:<tab>def __init__(self, nombre, edad):
		:<tab><tab>self._nombre = nombre
		:<tab><tab>self._edad = edad
		:<tab>@property
		:<tab>def nombre(self):
		:<tab><tab>return self._nombre
		:<tab>@nombre.setter
		:<tab>def nombre(self, nuevo_nombre):
		:<tab><tab>self._nombre = nuevo_nombre
		:hojo @nombre.setter @nombre es el nombre de
		:la funcion o variable.
		:
	*import math
		·20230927184558
		:Importa la libreria math
		:import math
		:math.ceil(4.2)
		:form math import ceil.
		:ceil(4.2)
		:floor(x)
		:ceil(x)
		:sqrt(x) = Raiz cuadrada
		:log(x) = Logaritmo
		:e = constante 2.71828
		:pi = constante 3.1415
		:sin() = seno
		:asing() = arcoseno
		:
	*Entrada, Impresion, Salida
		·20230927184558
		:print()
		:- Imprime un texto en pantalla.
		:print('Hola' + i + 'mundo')
		:- imprime el texto y concatena texto y numero.
		:variable = input()
		:- captura la linea de entrada y la guarda en variable
		:#comentario
		:- comenta la liena
		:
	*Funciones
		·20230927184558
		:Las funciones o subprocesos se establecen con la clave "def"
		:Esta funcion es la primera que se ejecuta por defecto
		:al entrar en una aplicacion.
		:Las variables dentro de la funcion solo funcionan dentro de la funcion.
		:A las funciones se les pueden pasar distintos argumentos o variables.
		:Estas varaibles pasadas si son de tipos basicos se crean duplicados y
		:no modifican el valor real de la variable pasada.(paso por valor)
		:Si las variables pasadas son de tipos complejos se trabajara sobre
		:la variable original sin crear copia (Paso por referencia.)
		:Una funcion puede retornar o no datos y pueden ser mas de un dato.
		:Si en un parametro de entrada le damos valor no sera oblicatorio y
		:tomara el valor que le demos por defecto.
		:-
		:#definicion Base de una funcion con dos entradas.
		:def main():
		:<tab>codigo
		:<tab>codigo
		:#Para pasar variables a una funcion.
		:def mi_funcion(arg1, arg2):
		:<tab>codigo
		:<tab>codigo
		:<tab>return Dato1,Dato2,DatoX
		:mi_funcion(variable1, variable2)
		:Las variables en pyton
		:-
		:VAR="hola"
		:def mi_funcion():
		:<tab>VAR = 10
		:<tab>print(VAR)
		:mi_funcion() # Esto imprimirá 10
		:# Fuera de la función, VAR no existe
		:print(VAR) # Esto generará un error NameError
		:-
		:Nombre="Casa";
		:print("EX",Nombre);
		:def F_01(M_Nombre):
		:<tab>print("IN",M_Nombre);
		:<tab>M_Nombre="OCUPADA";
		:<tab>print("IN",M_Nombre);
		:print("PRE",Nombre);
		:F_01(Nombre);
		:print("POS",Nombre);
		:#print(M_Nombre); Da error M_Nombre ya no existe.
		:-
		:Numero=20;
		:print("EX",Numero);
		:def F_01(M_Nombre):
		:<tab>print("IN",M_Nombre);
		:<tab>M_Nombre=50;
		:<tab>print("IN",M_Nombre);
		:print("PRE",Numero);
		:F_01(Numero);
		:print("POS",Numero);
		:#print(M_Nombre); Da error M_Nombre ya no existe.
		:-
		:mi_lista = [1, 2, 3]
		:print(mi_lista)
		:def modificar_lista(lista):
		:<tab>print(lista)
		:<tab>lista.append(4) # Esto modifica la lista original
		:print(mi_lista)
		:modificar_lista(mi_lista)
		:print(mi_lista) # Esto imprimirá [1, 2, 3, 4]
		:-
		:resultado1 = "A";
		:resultado2 = "A";
		:resultado3 = "A";
		:def obtener_resultados():
		:<tab>resultado1 = 10
		:<tab>resultado2 = "Hola"
		:<tab>resultado3 = [1, 2, 3]
		:-
		:<tab>print("IN",resultado1,resultado2,resultado3) # Esto imprimirá 10
		:<tab>return resultado3, resultado1, resultado2
		:-
		:print("INI",resultado1,resultado2,resultado3) # Esto imprimirá 10
		:# Llamando a la función y almacenando los resultados en variables
		:resultado1, resultado2, resultado3 = obtener_resultados()
		:print("OUT",resultado1,resultado2,resultado3) # Esto imprimirá 10
		:-
		:#Definimos la funcion con dos parametros
		:#solo el 1º oblicatorio
		:def F_Txt(Dat1,Dat2=""):
		:<t>M_Res="";M_Res1="Final";
		:<t>if(Dat2==""):
		:<t><t>M_Res=Dat1+" sin Dato";
		:<t>else:
		:<t><t>M_Res=Dat1+" "+Dat2;
		:<t>return M_Res,M_Res1;
		:#Creamos dos variables
		:V_Res1="";V_Res2="";
		:#Rescatamos de la funcion los dos parametros.
		:V_Res1,V_Res2 = F_Txt("Antonio");
		:#Imprimimos el resultado con texto formateado.
		:print(f"valor 1 ={V_Res1} Valor 2 ={V_Res2}");
		:#Rescatamos la funcion pero esta vez con 2 parametros.
		:V_Res1,V_Res2 = F_Txt("Antonio","Jesus");
		:#Imprimimos el resultado con texto formateado.
		:print(f"valor 1 ={V_Res1} Valor 2 ={V_Res2}");
		:
		*str()-Convierte en STRING un dato o variable
			·20230927184558
			ª10005
			:Retorna en formato STRING una variable u operacion matematica.
			:
		*type()-Nos devuelve el tipo de una variable
			·20230927184558
			:Nos devuelve el tipo de una variable.
			:
		*print()-Imprime datos en pantalla
			·20230927184558
			ª10006ª10007
			:Imprime datos en pantalla.
			:Podemos concatenarlos con , o con el operador +
			:teniendo en cuenta que con + tendrian que ser datos de tipo string.
			:Con el + usando numeros sumaria y mostraria los resultados.
			:#imprime los numeros 4,5,6 separados por , y terminado en +
			:print(4, 5, 6, sep=', ', end='. ')
			:Si queremos redondear a un numero limitado de decimales
			:podemos usar f.
			:-
			:V_Edad_Int=10;
			:V_EstaVivo_Boo=False;
			:V_Altura_Flo=1.123456;
			:print (V_Nombre_Str+" "+str(V_Edad_Int)+" "+str(V_EstaVivo_Boo));
			:print (V_Nombre_Str,V_Edad_Int,V_EstaVivo_Boo);
			:print (2+3+4+5);
			:print (V_Altura_Flo);
			:print (f"{V_Altura_Flo:.2f}");
			:
		*input("txt") Captura texto de entrada
			·20230927184558
			:La funcion Input nos permite preguntar y capturar un texto.
			:-
			:V_Curso_Str=input("Cual es tu curso?")
			:-
			:
		*upper() - Transforma valores a Mayusculas
			·20230927184558
			:Transforma un texto o una variable a mayusculas.
			:-
			:V_Curso_Str=input("Cual es tu curso?").upper();
			:print(V_Curso_Str.lower());
			:
		*lower() Trasforma valores a Minusculas
			·20230927184558
			:Transforma un texto o el valor de una variable a su
			:equivalente en minusculas.
			:-
			:V_Curso_Str=input("Cual es tu curso?").upper();
			:print(V_Curso_Str.lower());
			:
	*Instalacion
		·20230927184558
		:Podemos encontrar el compilador en
		:https://www.python.org/downloads/
		:
	*Listas - Arrays
		·20230927184558
		ª10011
		:-Una Tabla o Array es una lista de datos.
		:-Estos datos pueden ser de distintos tipos.
		:-Se pueden anidar unas Tablas dentro de otras dando
		:como resultado una Tabla de X dimensiones.
		:-
		:Tambien podemos crear una lista con un rango de valores
		:gracias a la funcion "list" y "range"
		:Tambien le podemos decir que nos muestre solo un rango de
		:valores con los [Pos1:Pos2].
		:-
		:V_Nombres_Lst = ["Juan","Pedro","Antonio"];
		:V_Cursos_Lst=[1,2,3,4,5,6];
		:V_Tabla_Lst=[[1,2,3], ["Anto","SDF","dfs"]];
		:V_Misto_Lst=["hola",20,True];
		:print(V_Nombres_Lst);
		:print(V_Nombres_Lst[0]);
		:print(V_Nombres_Lst[1]);
		:print(V_Nombres_Lst[2]);
		:print(V_Cursos_Lst);
		:print(V_Misto_Lst);
		:print(V_Tabla_Lst);
		:print(V_Tabla_Lst[1][1]);
		:print(V_Tabla_Lst[0][2]);
		:V_Rango_Lst=list(range(0,10));
		:print(V_Rango_Lst);
		:print(V_Rango_Lst[2:4]);
		:-
		:PS E:\TUTORIALES\PYTON\Proyectos\01> py var.py
		:['Juan', 'Pedro', 'Antonio']
		:Juan
		:Pedro
		:Antonio
		:[1, 2, 3, 4, 5, 6]
		:['hola', 20, True]
		:[[1, 2, 3], ['Anto', 'SDF', 'dfs']]
		:SDF
		:3
		:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		:[2, 3]
		:PS E:\TUTORIALES\PYTON\Proyectos\01>
		:
	*Tuplas - Tablas de Constantes
		·20230927184558
		:Son muy parecidas a las listas (Arrays)
		:No se mueden modificar. (son Constants)
		:Son mas rapidas que las tablas.
		:-
		:count(): Esta función se utiliza para contar cuántas veces aparece un elemento en una tupla.
		:index(): Esta función se utiliza para encontrar el índice (posición) de la primera aparición de un elemento en una tupla. Si el elemento no está presente, generará una excepción ValueError.
		:__add__(): Este es un método especial que permite concatenar dos tuplas utilizando el operador +.
		:__annotations__: Este atributo se utiliza en el contexto de la anotación de tipo (type hinting) en Python. Contiene información sobre las anotaciones de tipo de una función.
		:__class__: Este atributo devuelve la clase a la que pertenece un objeto. En el caso de una tupla, será la clase tuple.
		:__class_getitem__(): Este método se utiliza para personalizar la recuperación de elementos de una clase genérica. No es comúnmente utilizado con tuplas.
		:__contains__(): Este método se utiliza para verificar si un elemento está presente en una tupla. Retorna True si el elemento está presente y False si no lo está.
		:__delattr__(): Este método se utiliza para eliminar un atributo de un objeto. No es comúnmente utilizado con tuplas.
		:__dict__: Este atributo es un diccionario que contiene los atributos del objeto. No es comúnmente utilizado con tuplas.
		:__dir__(): Este método se utiliza para obtener una lista de nombres de atributos y métodos válidos en un objeto.
		:__doc__: Este atributo contiene la cadena de documentación (docstring) asociada con un objeto.
		:__eq__(): Este método se utiliza para verificar si dos objetos son iguales. En el caso de tuplas, compara sus elementos para determinar la igualdad.
		:-
		:V_Constant_Tbl=("pedro","juan","antonio","roca");
		:print(type(V_Constant_Tbl));
		:print(V_Constant_Tbl[2]);
		:-
		:PS E:\TUTORIALES\PYTON\Proyectos\01> py var.py
		:<class 'tuple'>
		:antonio
		:PS E:\TUTORIALES\PYTON\Proyectos\01>
		:-
		:# Definir una tupla de cadenas de texto
		:mi_tupla = ("manzana", "banana", "cereza", "dátil", "uva")
		:# Elemento a buscar
		:elemento = "pera"
		:try:
		:<tab># Intentar encontrar la posición del elemento en la tupla
		:<tab>indice = mi_tupla.index(elemento)
		:<tab>print(f"El elemento '{elemento}' está en la posición {indice}")
		:except ValueError as e:
		:<tab># Manejar el caso en que el elemento no se encuentra en la tupla
		:<tab>print(f"El elemento '{elemento}' no se encuentra en la tupla.")
		:<tab>print(f"Descripción del error: {str(e)}")
		:
	*[Modulos precargados]
		·20230927184558
		:Pyton por defecto precarga un monton de modulos de serie.
		:Para acceder a estos modulos podemos usar el codigo
		:-
		:import pkgutil
		:# Obtener una lista de todos los módulos en la biblioteca estándar
		:modules = [name for _, name, _ in pkgutil.iter_modules()]
		:# Mostrar la lista de módulos
		:print(modules)
		:# Imprimir cada nombre de módulo en una línea
		:for module in modules:
		:<tab>print(module)
		:-
		:Para ver los submodulos de las clases usaremos.
		:import http
		:# Obtener una lista de todos los módulos en el módulo http
		:http_modules = [name for _, name, _ in pkgutil.iter_modules(http.__path__)]
		:# Imprimir cada nombre de módulo en una línea
		:for module in http_modules:
		:<tab>print(module)
		:-
		:Var
		:math ->Proporciona funciones matemáticas y constantes.
		:_asyncio
		:_bz2
		:_ctypes
		:_ctypes_test
		:_decimal
		:_elementtree
		:_hashlib
		:_lzma
		:_msi
		:_multiprocessing
		:_overlapped
		:_queue
		:_socket
		:_sqlite3
		:_ssl
		:_testbuffer
		:_testcapi
		:_testconsole
		:_testimportmultiple
		:_testinternalcapi
		:_testmultiphase
		:_tkinter
		:_uuid
		:_zoneinfo
		:pyexpat
		:select
		:unicodedata
		:winsound
		:__future__
		:__hello__
		:__phello__
		:_aix_support
		:_bootlocale
		:_bootsubprocess
		:_collections_abc
		:_compat_pickle
		:_compression
		:_dummy_thread
		:_markupbase
		:_osx_support
		:_py_abc
		:_pydecimal
		:_pyio
		:_sitebuiltins
		:_strptime
		:_threading_local
		:_weakrefset
		:abc
		:aifc
		:antigravity
		:argparse
		:ast
		:asynchat
		:asyncio
		:asyncore
		:base64
		:bdb
		:binhex
		:bisect
		:bz2
		:cProfile
		:calendar
		:cgi
		:cgitb
		:chunk
		:cmd
		:code
		:codecs
		:codeop
		:collections -> Ofrece tipos de datos especializados como diccionarios ordenados (OrderedDict) y colas (deque).
		:colorsys
		:compileall
		:concurrent
		:configparser
		:contextlib
		:contextvars
		:copy
		:copyreg
		:crypt
		:csv -> Facilita la lectura y escritura de archivos CSV.
		:ctypes
		:curses
		:dataclasses
		:datetime -> Facilita la manipulación de fechas y horas.
		:dbm
		:decimal
		:difflib
		:dis
		:distutils
		:doctest
		:dummy_threading
		:email
		:encodings
		:ensurepip
		:enum ->Proporciona expresiones regulares para el procesamiento de cadenas de texto.
		:filecmp
		:fileinput
		:fnmatch
		:formatter
		:fractions
		:ftplib
		:functools
		:genericpath
		:getopt
		:getpass
		:gettext
		:glob
		:graphlib
		:gzip
		:hashlib
		:heapq
		:hmac
		:html
		:http -> proporciona funcionalidades para trabajar con protocolos HTTP
		:idlelib
		:imaplib
		:imghdr
		:imp
		:importlib
		:inspect
		:io
		:ipaddress
		:json -> Permite trabajar con datos en formato JSON.
		:keyword
		:lib2to3
		:linecache
		:locale
		:logging
		:lzma
		:mailbox
		:mailcap
		:mimetypes
		:modulefinder
		:msilib
		:multiprocessing
		:netrc
		:nntplib
		:ntpath
		:nturl2path
		:numbers
		:opcode
		:operator
		:optparse
		:os ->Permite la interacción con el sistema operativo, como el acceso a archivos y directorios.
		:pathlib
		:pdb
		:pickle
		:pickletools
		:pipes
		:pkgutil
		:platform
		:plistlib
		:poplib
		:posixpath
		:pprint
		:profile
		:pstats
		:pty
		:py_compile
		:pyclbr
		:pydoc
		:pydoc_data
		:queue
		:quopri
		:random -> Permite la generación de números aleatorios.
		:re -> Proporciona expresiones regulares para el procesamiento de cadenas de texto.
		:reprlib
		:rlcompleter
		:runpy
		:sched
		:secrets
		:selectors
		:shelve
		:shlex
		:shutil
		:signal
		:site
		:smtpd
		:smtplib
		:sndhdr
		:socket -> Proporciona funcionalidades para programacion de red.
		:socketserver
		:sqlite3 -> Ofrece acceso a bases de datos SQLite.
		:sre_compile
		:sre_constants
		:sre_parse
		:ssl
		:stat
		:statistics
		:string
		:stringprep
		:struct
		:subprocess
		:sunau
		:sys -> Ofrece acceso a variables y funciones específicas del sistema.
		:symbol
		:symtable
		:sysconfig
		:tabnanny
		:tarfile
		:telnetlib
		:tempfile
		:test
		:textwrap
		:this
		:threading
		:timeit
		:tkinter
		:token
		:tokenize
		:tomllib
		:trace
		:traceback
		:tracemalloc
		:tty
		:turtle
		:turtledemo
		:types
		:typing
		:unittest
		:urllib
		:uu
		:uuid
		:venv
		:warnings
		:wave
		:weakref
		:webbrowser
		:wsgiref
		:xdrlib
		:xml
		:xmlrpc
		:zipapp
		:zipfile
		:zipimport
		:zoneinfo
		:_distutils_hack
		:easy_install
		:pip
		:pkg_resources
		:setuptools
		:
	*Modulos
		·20230927184558
		:Modulos o Librerias
		:Son un conjunto de funciones, estructuras y variables que
		:vienen pregeneradas y agrupadas para ayudar en el
		:desarrollo de aplicaciones.
		:
		*Var
			·20230927165838
		*_asyncio
			·20230927165838
		*_bz2
			·20230927165838
		*_ctypes
			·20230927165838
		*_ctypes_test
			·20230927165838
		*_decimal
			·20230927165838
		*_elementtree
			·20230927165838
		*_hashlib
			·20230927165838
		*_lzma
			·20230927165838
		*_msi
			·20230927165838
		*_multiprocessing
			·20230927165838
		*_overlapped
			·20230927165838
		*_queue
			·20230927165838
		*_socket
			·20230927165838
		*_sqlite3
			·20230927165838
		*_ssl
			·20230927165838
		*_testbuffer
			·20230927165838
		*_testcapi
			·20230927165838
		*_testconsole
			·20230927165838
		*_testimportmultiple
			·20230927165838
		*_testinternalcapi
			·20230927165838
		*_testmultiphase
			·20230927165838
		*_tkinter
			·20230927165838
		*_uuid
			·20230927165838
		*_zoneinfo
			·20230927165838
		*pyexpat
			·20230927165838
		*select
			·20230927165838
		*unicodedata
			·20230927165838
		*winsound
			·20230927165838
		*__future__
			·20230927165838
		*__hello__
			·20230927165838
		*__phello__
			·20230927165838
		*_aix_support
			·20230927165838
		*_bootlocale
			·20230927165838
		*_bootsubprocess
			·20230927165838
		*_collections_abc
			·20230927165838
		*_compat_pickle
			·20230927165838
		*_compression
			·20230927165838
		*_dummy_thread
			·20230927165838
		*_markupbase
			·20230927165838
		*_osx_support
			·20230927165838
		*_py_abc
			·20230927165838
		*_pydecimal
			·20230927165838
		*_pyio
			·20230927165838
		*_sitebuiltins
			·20230927165838
		*_strptime
			·20230927165838
		*_threading_local
			·20230927165838
		*_weakrefset
			·20230927165838
		*abc
			·20230927165838
		*aifc
			·20230927165838
		*antigravity
			·20230927165838
		*argparse
			·20230927165838
		*ast
			·20230927165838
		*asynchat
			·20230927165838
		*asyncio
			·20230927165838
		*asyncore
			·20230927165838
		*base64
			·20230927165838
		*bdb
			·20230927165838
		*binhex
			·20230927165838
		*bisect
			·20230927165838
		*bz2
			·20230927165838
		*cProfile
			·20230927165838
		*calendar
			·20230927165838
		*cgi
			·20230927165838
		*cgitb
			·20230927165838
		*chunk
			·20230927165838
		*cmd
			·20230927165838
		*code
			·20230927165838
		*codecs
			·20230927165838
		*codeop
			·20230927165838
		*collections
			·20230927165838
		*colorsys
			·20230927165838
		*compileall
			·20230927165838
		*concurrent
			·20230927165838
		*configparser
			·20230927165838
		*contextlib
			·20230927165838
		*contextvars
			·20230927165838
		*copy
			·20230927165838
		*copyreg
			·20230927165838
		*crypt
			·20230927165838
		*csv
			·20230927165838
		*ctypes
			·20230927165838
		*curses
			·20230927165838
		*dataclasses
			·20230927165838
		*datetime
			·20230927165838
		*dbm
			·20230927165838
		*decimal
			·20230927165838
		*difflib
			·20230927165838
		*dis
			·20230927165838
		*distutils
			·20230927165838
		*doctest
			·20230927165838
		*dummy_threading
			·20230927165838
		*email
			·20230927165838
		*encodings
			·20230927165838
		*ensurepip
			·20230927165838
		*enum
			·20230927165838
		*filecmp
			·20230927165838
		*fileinput
			·20230927165838
		*fnmatch
			·20230927165838
		*formatter
			·20230927165838
		*fractions
			·20230927165838
		*ftplib
			·20230927165838
		*functools
			·20230927165838
		*genericpath
			·20230927165838
		*getopt
			·20230927165838
		*getpass
			·20230927165838
		*gettext
			·20230927165838
		*glob
			·20230927165838
		*graphlib
			·20230927165838
		*gzip
			·20230927165838
		*hashlib
			·20230927165838
		*heapq
			·20230927165838
		*hmac
			·20230927165838
		*html
			·20230927184558
			:Proporciona comandos para ejecutar conexiones HTTP
			:Podemos ver sus subclases con:
			:-
			:import http
			:# Obtener una lista de todos los módulos en el módulo http
			:http_modules = [name for _, name, _ in pkgutil.iter_modules(http.__path__)]
			:# Imprimir cada nombre de módulo en una línea
			:for module in http_modules:
			:<tab>print(module)
			:-
			:Podemos montar un servidor http en el puerto 8000
			:sirviendo los ficheros del dierectorio del ejecutable con:
			:-
			:from http.server import SimpleHTTPRequestHandler
			:import socketserver
			:# Configurar el manejador del servidor
			:handler = SimpleHTTPRequestHandler
			:# Crear un servidor en el puerto 8000
			:with socketserver.TCPServer(("", 8000), handler) as httpd:
			:<tab>print("Servidor web en ejecución en el puerto 8000...")
			:<tab>httpd.serve_forever()
			:-
			:
		*http
			·20230927165838
		*idlelib
			·20230927165838
		*imaplib
			·20230927165838
		*imghdr
			·20230927165838
		*imp
			·20230927165838
		*importlib
			·20230927165838
		*inspect
			·20230927165838
		*io
			·20230927165838
		*ipaddress
			·20230927165838
		*json
			·20230927165838
		*keyword
			·20230927165838
		*lib2to3
			·20230927165838
		*linecache
			·20230927165838
		*locale
			·20230927165838
		*logging
			·20230927165838
		*lzma
			·20230927165838
		*mailbox
			·20230927165838
		*mailcap
			·20230927165838
		*mimetypes
			·20230927165838
		*modulefinder
			·20230927165838
		*msilib
			·20230927165838
		*multiprocessing
			·20230927165838
		*netrc
			·20230927165838
		*nntplib
			·20230927165838
		*ntpath
			·20230927165838
		*nturl2path
			·20230927165838
		*numbers
			·20230927165838
		*opcode
			·20230927165838
		*operator
			·20230927165838
		*optparse
			·20230927165838
		*os
			·20230927165838
		*pathlib
			·20230927165838
		*pdb
			·20230927165838
		*pickle
			·20230927165838
		*pickletools
			·20230927165838
		*pipes
			·20230927165838
		*pkgutil
			·20230927165838
		*platform
			·20230927165838
		*plistlib
			·20230927165838
		*poplib
			·20230927165838
		*posixpath
			·20230927165838
		*pprint
			·20230927165838
		*profile
			·20230927165838
		*pstats
			·20230927165838
		*pty
			·20230927165838
		*py_compile
			·20230927165838
		*pyclbr
			·20230927165838
		*pydoc
			·20230927165838
		*pydoc_data
			·20230927165838
		*queue
			·20230927165838
		*quopri
			·20230927165838
		*random
			·20230927184558
			:Nos permite generar numeros aleatorios.
			:-
			:import random;
			:print ("ejemplo Generar numero aleatorio");
			:#generamos un numero aleatorio entre el 1 y el 30
			:print ("Numero generado:",random.randint(1,30));
			:#generamos un numero aleatorio X Bytes
			:print ("Numero generado:",random.randbytes(1));
			:
		*re
			·20230927165838
		*reprlib
			·20230927165838
		*rlcompleter
			·20230927165838
		*runpy
			·20230927165838
		*sched
			·20230927165838
		*secrets
			·20230927165838
		*selectors
			·20230927165838
		*shelve
			·20230927165838
		*shlex
			·20230927165838
		*shutil
			·20230927165838
		*signal
			·20230927165838
		*site
			·20230927165838
		*smtpd
			·20230927165838
		*smtplib
			·20230927165838
		*sndhdr
			·20230927165838
		*socket
			·20230927165838
		*socketserver
			·20230927165838
		*sqlite3
			·20230927165838
		*sre_compile
			·20230927165838
		*sre_constants
			·20230927165838
		*sre_parse
			·20230927165838
		*ssl
			·20230927165838
		*stat
			·20230927165838
		*statistics
			·20230927165838
		*string
			·20230927165838
		*stringprep
			·20230927165838
		*struct
			·20230927165838
		*subprocess
			·20230927165838
		*sunau
			·20230927165838
		*symbol
			·20230927165838
		*symtable
			·20230927165838
		*sysconfig
			·20230927165838
		*tabnanny
			·20230927165838
		*tarfile
			·20230927165838
		*telnetlib
			·20230927165838
		*tempfile
			·20230927165838
		*test
			·20230927165838
		*textwrap
			·20230927165838
		*this
			·20230927165838
		*threading
			·20230927165838
		*timeit
			·20230927165838
		*tkinter
			·20230927165838
		*token
			·20230927165838
		*tokenize
			·20230927165838
		*tomllib
			·20230927165838
		*trace
			·20230927165838
		*traceback
			·20230927165838
		*tracemalloc
			·20230927165838
		*tty
			·20230927165838
		*turtle
			·20230927165838
		*turtledemo
			·20230927165838
		*types
			·20230927165838
		*typing
			·20230927165838
		*unittest
			·20230927165838
		*urllib
			·20230927165838
		*uu
			·20230927165838
		*uuid
			·20230927165838
		*venv
			·20230927165838
		*warnings
			·20230927165838
		*wave
			·20230927165838
		*weakref
			·20230927165838
		*webbrowser
			·20230927165838
		*wsgiref
			·20230927165838
		*xdrlib
			·20230927165838
		*xml
			·20230927165838
		*xmlrpc
			·20230927165838
		*zipapp
			·20230927165838
		*zipfile
			·20230927165838
		*zipimport
			·20230927165838
		*zoneinfo
			·20230927165838
		*_distutils_hack
			·20230927165838
		*easy_install
			·20230927165838
		*pip
			·20230927165838
		*pkg_resources
			·20230927165838
		*setuptools
			·20230927165838
	*Bucle While
		·20230927184558
		:El While es una instrucion donde se ejecutaran las sentencias
		:dentro del while MIENTRAS se cumpla la condicion.
		:En este caso nosotros tendremos que controlar la condicion de salida
		:y la variable usada.
		:-
		:# Tabla de multiplicar con While
		:print("Ejemplo Tabla de multiplicar con While")
		:V_Num1_Int=0;
		:V_Num2_Int=0;
		:V_Res_Str="";
		:while V_Num1_Int<=10:
		:# Tambien acepta entre parentesis.(V_Num2_Int<=10)
		:<t>while V_Num2_Int<=10:
		:<t><t>V_Res_Str+=">"+str(V_Num1_Int)+"*"+str(V_Num2_Int)+"="+str((V_Num1_Int*V_Num2_Int))+" ";
		:<t><t>V_Num2_Int+=1;
		:<t><t>V_Num1_Int+=1;
		:<t>V_Num2_Int=0;# Reset Variable contador.
		:<t>print(V_Res_Str);
		:-
		:NT: Nota que a la salida del segundo While reseteo su variable contador.
		:
	*FRAMEWORKS
		·20230927184558
		:Son un conjunto de librerias que nos permiten
		:aguilizar la programacion el pyton.
		:Algunos son:
		:Django
		:Flask
		:Pyramid
		:Bottle
		:Turbogears
		:
	*TRABAJO
		·20230927184558
		:Como conseguir curro de pyton.
		:-Workana
		:(Se encargan del arbitraje.)
		:(Cuanto mas trabajos tengas mejor sera)
		:(Trabajo remoto)
		:(Tasas muy altas 4,5% del final del trabajador y
		:el 20% de tu dato.)
		:(Crear perfil atractivo. mirar los que tengan mas
		:proyectos en curso.)
		:-Fiver
		:-Upwork
		:-Freelancer.
		:-
		:Tambien en
		:Mil Anuncios
		:Walapop.
		:-
		:Tambien podriamos
		:crear una web con el porfolio
		:para mostrar lo que haces.
		:-
		:Como cobrar.
		:50% por adelantado.
		:50% al terminar el proyecto.
		:y expecificar un final de proyecto
		:15 dias de revision y despues cerrado.
		:-
		:
